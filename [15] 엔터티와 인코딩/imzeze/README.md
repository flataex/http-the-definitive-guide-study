# 엔터티와 인코딩

HTTP는 엔터티를 사용해 다음을 보장한다.

- `Content-Type`과 `Content-Language` 헤더를 이용해 브라우저나 클라이언트는 콘텐츠를 올바르게 처리할 수 있다.
- `Content-Language`와 `Content-Encoding` 헤더를 이용해 올바르게 압축을 해제할 수 있다.
- 엔터티 검사와 캐시 만료 제어를 이용해 객체를 항상 최신상태로 유지한다.
- `Accept` 관련 헤더에 기반해 사용자의 요구를 만족시킨다.
- 네트워크 사이를 빠르고 효율적으로 이동한다.
- 전송 인코딩 헤더와 `Content-MD5` 체크섬을 이용해 조작되지 않는다.

<br />

## 메시지는 컨테이너, 엔터티는 화물

<img width="391" alt="image" src="https://github.com/flataex/http-the-definitive-guide-study/assets/67260437/2d76702b-ce45-4f05-aab5-9f4c3f61812a">

### 엔터티 본문

엔터티 본문은 가공되지 않은 데이터만 담고 있고, 다른 정보들은 모두 헤더에 담겨 있다. 따라서 엔터티 헤더는 엔터티 본문의 의미에 대해 설명할 필요가 있다.

### 엔터티 헤더

**Content-Type**  
엔터티 본문의 MIME 타입을 기술한다. 컨텐츠 인코딩을 거친 경우에도 엔터티 본문의 유형을 명시한다.

<img width="580" alt="image" src="https://github.com/flataex/http-the-definitive-guide-study/assets/67260437/5e7d5513-f0e8-4741-9154-a7e94d1cbb7c">

- 유형을 더 자세히 지정하기 위해 `charset` 매개변수를 지원한다.
- 멀티타입 메시지는 여러 개의 메시지를 포함하며 하나의 복합 메시지로 보내준다. 각 메시지는 자신만의 헤더를 가진다.
  - 멀티파트 폼  
     텍스트 필드와 업로드 객체는 하나의 메시지로 보내진다.
  - 범위 요청에 대한 응답 또한 멀티파트가 될 수 있다. (multipart/byteranges)

**Content-Length**  
엔터티 본문의 크기를 바위트 단위로 나타낸다.  
청크 인코딩으로 전송하지 않는 이상 엔터티 본문을 포함한 메시지에서는 이 헤더를 반드시 갖고 있어야한다.

- 잘림 검출  
   Content-Length 헤더를 이용해 메시지가 모두 전송되어 커넥션이 닫힌 것인지, 메시지가 전송 중에 모두 전송되지 못하고 충돌이 발생한 것인지 확인할 수 있다.  
   캐싱 프락시 서버는 잘린 메시지를 캐싱하지 않기 위해 Content-Length 헤더가 없는 메시지는 캐시하지 않는다.
- 지속 커넥션  
   Content-Length 헤더는 지속 커넥션에서 필수 값이다.
- 길이 판별 규칙
  - HEAD 메소드에 대한 응답과 같이 본문이 허용되지 않는 메시지에서는 Content-Length 헤더가 무시된다.
  - 메시지가 Transfer-Encoding 헤더를 포함하고 있다면 엔터티는 `0바이트 청크`라고 불리는 패턴으로 끝나야하며 Content-Length헤더는 무시해야한다. 전송 인코딩은 엔터티 본문을 바꾸기 때문이다.
  - 컨텐츠가 인코딩되어 있다면 Content-Length는 인코딩된 본문의 길이로 정의된다.
  - 메시지 타입이 `multipart/byteranges`고 엔터티 길이가 별도로 정의되지 않았다면 각 멀티파트가 크기를 정의한다. 따라서 수신자가 이를 해석할 수 있다는 사실을 확인하기 전에는 이 타입을 보내지 말아야한다.
  - 위의 어떤 규칙에도 포함되지 않는다면 엔터티는 커넥션이 닫힐 때 끝난다. 커넥션은 오직 서버만이 닫을 수 있다.

**Content-Language**  
객체에 잘 대응되는 자연어

**Content-Encoding**  
객체 인코딩에 쓰인 알고리즘 명시  
보안이나 메시지 크기를 줄이기 위해 컨텐츠를 인코딩한다.

<img width="587" alt="image" src="https://github.com/flataex/http-the-definitive-guide-study/assets/67260437/be4cf664-faab-4a05-9767-91661e4fc74e">

- Accept-Encoding  
   클라이언트는 자신이 지원하는 인코딩 목록을 Accept-Encoding 헤더를 통해 전달한다. 만약 헤더가 없다면 서버는 모든 인코딩이 허용되는 것으로 간주한다.
  - q 매개변수를 이용해 선호도를 나타낼 수 있다. (1~0)

**Content-MD5**  
엔터티 본문의 컨텐츠에 대해 MD5 알고리즘을 적용한 결과를 보낸다.(컨텐츠 인코딩)  
MD5는 메시지 무결성 검사 뿐만 아니라 문서의 위치를 빠르게 찾아내고 컨텐츠 중복 방지를 위한 해시 테이블 키 값으로 쓰일 수도 있다.

**Content-Location**  
요청 시점을 기준으로, 객체의 또 다른 위치

**Content-Rage**  
부분 엔터티인 경우, 전체 엔터티의 어느 부분에 해당하는지 정의

**Last-Modified**  
컨텐츠 생성/수정 날짜

**Expires**  
캐시 만료 날짜 및 시각

**Allow**  
허용되는 요청 메서드

**ETag**  
인스턴스 고유 검사기

**Cache-Control**  
캐시 방법에 대해 정의

<br />

## 전송 인코딩과 청크 인코딩

전송 인코딩은 메시지 전체에 적용되어, 메시지의 구조를 바꾼다.

### Transfer-Encoding 헤더

전송 인코딩에 어떤 알고리즘이 쓰였는지 명시한다. 최근 HTTP 명세는 청크 인코딩만 정의되어 있다.

> 어떤 전송 인코딩을 사용할 수 있는지 서버에게 알려주기 위해서는 TE 헤더를 사용한다.

### 청크 인코딩

메시지를 일정 크기의 여럿 청크로 쪼개 순차적으로 전송한다. 청크 인코딩을 이용하면 메시지를 보내기 전에 메시지의 전체 크기를 알 필요가 없다.

지속 커넥션에서 컨텐츠가 동적으로 생성된다면 서버는 보내기 전에 메시지의 전체 크기를 알 수 없다. 청크 인코딩을 사용하면 이를 해결할 수 있고, 메시지가 끝났음을 알리기 위해 크기가 0인 청크를 보낸다.

클라이언트 또한 청크 인코딩된 데이터를 서버에 전송할 수 있다. 하지만 서버가 청크 인코딩을 받아들이지 못한다면 411 코드(Length Required; Content-Length가 필요함)으로 응답한다.

**트레일러**  
TE에 트레일러가 포함되어 있거나 서버에서만 사용되는 경우 청크 메시지에 트레일러가 포함될 수 있다.  
트레일러에는 메시지 시작 시점에는 알 수 없는 추가적인 헤더 필드를 담을 수 있다.  
ex) Content-MD5 등

### 전송 인코딩 규칙

- 전송 인코딩 집합은 반드시 `chunked`를 포함해야한다.
- 청크 전송 인코딩이 사용되었다면 메시지 본문에 적용된 마지막 전송 인코딩이 존재해야한다.
- 청크 전송 인코딩은 반드시 메시지 본문에 한 번 이상 적용되어야한다.

<br />

## 시간에 따라 바뀌는 인스턴스

클라이언트는 같은 리소스를 요청했지만, 시간의 흐름에 따라 다른 인스턴스를 받을 수 있다.

`인스턴스 조작`이란 클라이언트와 서버가 갖고 있는 리소스가 같은 것인지 판단하고 새 인스턴스를 요청하는 방법으로, 범위 요청과 델타 인코딩이 여기 속한다.

<br />

## 검사기와 신선도

1. 클라이언트가 리소스의 사본을 요청한다.
2. 서버가 리소스(버전 1)로 응답한다.
3. 클라이언트가 사본을 캐시하고 만료되기 전까지 이를 사용한다.
4. 리소스가 만료되면 클라이언트는 서버에 다시 사본을 요청한다.
   조건부 요청은 서버에게 리소스가 변경되었을 때만 사본을 보내달라고 요청하는 것이다.

### 신선도

서버는 Expires나 Cache-Control 헤더를 사용해 리소스의 신선도에 대한 정보를 제공할 수 있다.

- Expires  
   만료 날짜를 명시한다.
- Cache-Control  
   리소스의 최대 수명을 초 단위로 정의한다. (7장 참고)

### 조건부 요청과 검사기

HTTP는 리소스가 바뀐 경우에만 사본을 요청하는 `조건부 요청`을 제공한다. 조건부 헤더는 조건이 참일 때만 수행되도록 하며 조건이 거짓이면 서버는 에러코드를 돌려보낸다. (7장 참고)

HTTP 검사기에는 약한 검사기와 강한 검사기가 있다. 약한 검사기는 인스턴스를 고유하게 식별하지 못하는 경우가 있고, 강한 검사기는 항상 고유하게 식별한다. (7장 참고)

> 약한 검사기 - 바이트 검사, 마지막 수정 시각 검사 등  
> 강한 검사기 - 체크섬 검사, ETag 검사 등

<br />

## 범위 요청

클라이언트가 문서의 일부분이나 특정 범위만 요청할 수 있다.

> ex) 엔터티를 다운 받던 중 중단된 시점부터 재개할 수 있다.

서버는 클라이언트에게 자신이 범위를 받아들일 수 있는지 Accept-Range 헤더를 이용해 알려줄 수 있다.

<br />

## 델타 인코딩

델타 인코딩은 리소스가 변했을 때, 새 페이지 전체를 보내는 것이 아닌 변경된 부분만 보낼 수 있는 방법이다.

1. 클라이언트는 자신이 갖고 있는 페이지 버전과 델타를 처리할 수 있는 알고리즘을 알려준다.
2. 서버는 이 값을 보고 클라이언트가 델타를 처리할 수 있다고 이해한다.
3. 서버는 델타를 계산해 새 식별자(ETag) 등과 함께 클라이언트에게 보낸다.

클라이언트는 If-None-Match에 자신이 갖고 있는 페이지 버전을 보내거나 A-IM에 처리할 수 있는 델타 알고리즘을 명시할 수 있고, 서버는 IM에 델타를 계산하는 데 사용된 알고리즘을 명시할 수 있다.
