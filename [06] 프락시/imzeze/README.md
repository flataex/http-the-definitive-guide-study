# 프록시

## 웹 중개자

HTTP 프록시 서버는 웹 서버이기도 하고 웹 클라이언트이기도 하다.  
<img width="777" alt="image" src="https://github.com/flataex/http-the-definitive-guide-study/assets/67260437/fe90d640-df92-4d8d-96ec-3dbc1ad65ee3">

### 개인프록시와 공유 프록시

하나의 클라이언트만을 위한 프록시를 개인 프록시라고 부르고, 여러 클라이언트가 함께 사용하는 프록시를 공용 프록시라고 부른다.

#### 공용 프록시

- 대부분의 프록시는 공용이다.
- 중앙 집중형 프록시가 관리하기 더 쉽다.
- 캐시 프록시와 같은 프록시 애플리케이션은 클라이언트가 많을수록 유리하다.

#### 개인 프록시

- 주로 클라이언트 컴퓨터에서 실행되는 형태로 쓰인다.
- ISP(결제 서비스)와 같이 브라우저의 기능을 확장하거나 개선하는 데에 쓰인다.

### 프록시 대 게이트웨이

원칙적으로 프록시는 같은 프로토콜을 이용하는 애플리케이션을 연결하고, 게이트웨이는 다른 프로토콜을 이용하는 애플리케이션을 연결하는 데에 쓰인다.

<img width="777" alt="image" src="https://github.com/flataex/http-the-definitive-guide-study/assets/67260437/df85967d-a060-4f41-81ec-49ecfdeb61fc">

위 HTTP/POP 게이트웨이는 **웹 트랜잭션을 적절 한 POP 트랜잭션으로** 변환하고, 사용자가 **이메일을 HTTP를 통해 읽을 수 있게** 해준다.

실직적으로는 프록시도 게이트웨이 역할을 하기도 한다. 다른 버전의 HTTP 트랜잭션을 대응하거나, SSL 보안 프로토콜, SOCKS 방화벽, FTP 접근 등을 지원한다.

<br />

## 왜 프록시를 사용하는가?

#### 프록시 사용 예

- 어린이 필터  
   성인 콘텐츠를 차단하는 **필터링 프록시**
- 문서 접근 제어자  
   다양한 웹 서버에 대한 **접근 제어**를 중앙 프록시 서버에서 단일하게 설정할 수 있다.
- 방화벽 프록시
  - 클라이언트의 요청을 받아 서버에 데이터를 요청해 응답을 전달한다.
  - 클라이언트 대신에 프록시 서버가 서버에 접속하기 때문에 클라이언트의 주소를 숨길 수 있고, 클라이언트는 직접 인터넷에 접속하지 않고 프록시 서버에 접속해 서버에 접근할 수 있다. (포워드 프록시)
    <img width="780" alt="image" src="https://github.com/flataex/http-the-definitive-guide-study/assets/67260437/5fc334b6-bc53-4296-a888-ff9e2fe38629">
- 웹 캐시
  - 자주 읽히는 데이터를 로컬에 캐시해두고, 동일한 요청에 대해 캐시된 데이터를 전달한다.
  - 인터넷 커뮤니케이션이 줄어들고, 근거리 캐시 프록시에서 데이터를 받을 수 있다.
- 대리 프락시  
   클라이언트로부터 진짜 웹서버인 것처럼 요청을 받아 내부 서버에 접속해 데이터를 받는다. (리버스 프록시)
- 콘텐츠 라우터  
   인터넷 트래픽 조건과 콘텐츠의 종류에 따라 요청을 특정 웹 서버로 유도하는 콘텐츠 라우터로 동작할 수 있다.
  > 사용자가 더 높은 성능을 위해 돈을 지불했다면 콘텐츠 라우터는 요청을 가까운 복제 캐시로 전달할 수 있다.
- 트랜스코더  
   데이터를 변환해 클라이언트에 전달하는 역할을 한다.
  > 크기를 줄이기 위해 GIF를 JPG로 변환할 수 있다.  
  > 번역 파일을 제공할 수 있다.
- 익명화 프락시  
   HTTP 메시지에서 신원을 식별할 수 있는 IP 주소, From 헤더, 쿠키 등을 헤더에서 제거함으로써 익명성과 개인정보보호에 기여한다.

<br />

## 프락시는 어디에 있는가?

### 프락시 서버 배치

어떻게 프락시가 네트워크에 배치되는가

<img width="596" alt="image" src="https://github.com/flataex/http-the-definitive-guide-study/assets/67260437/7e8b36f6-271e-4f53-bd4d-03e3d593aa55">

#### 출구 프록시

- 로컬 네트워크의 출구에 위치하는 프록시
- ex) 필터링 프록시

#### 입구 프록시

- 모든 요청을 종합적으로 처리하기 위해 ISP(Internet Service Provider) 접근 지점에 위치하는 프록시
- ex) 캐시 프록시

#### 대리 프락시(리버스 프록시)

- 네트워크의 가장 끝에 있는 웹 서버들의 바로 앞에 위치하는 프록시
- 자원을 요청하거나 보안 기능을 추가할 수 있다.

#### 네트워크 교환 프락시

- 캐시를 이용해 인터넷 혼잡도를 낮추고 트래픽 흐름을 감시하기 위해 네트워크 사이사이에 배치하는 프록시

### 프락시 계층

프락시 계층에서 프락시 서버들은 부모와 자식의 관계를 갖는다.

> 인바운드-부모 / 아웃바운드-자식

#### 프락시 계층 콘텐츠 라우팅

기본적으로 프락시 계층은 정적이다. A 프록시의 이전 프록시가 어디인지, 이후 프록시가 어디인지가 정해져있다. 그러나 계층이 반드시 정적이어야 하는 것은 아니다. **접근 프락시**는 상황에 맞게 부모 프락시나 원 서버에게 라우팅한다.

**동적부모선택**

- 부하 균형  
   부모 프록시의 작업량을 고려하여 부모 프락시를 선택한다.
- 지리적 인접성에 근거한 라우팅
- 프로토콜/타입 라우팅
- 유료 서비스 가입자를 위한 라우팅

### 어떻게 프락시가 트래픽을 처리하는가

클라이언트 트래픽이 프락시로 가도록 만드는 방법에는 다음 네 가지가 있다.

- **클라이언트를 수정한다**  
   웹 클라이언트들은 수동 혹은 자동 프락시 설정을 지원한다. 클라이언트가 프락시를 사용하도록설정 되어 있다면, 클라이언트는 HTTP 요청을 프락시로 보낸다.  
   <img width="592" alt="image" src="https://github.com/flataex/http-the-definitive-guide-study/assets/67260437/ad5e6511-a90a-4613-9022-7d7fa8d3ed23">

  [설정 방법]

  - 수동 설정  
    클라이언트에서 명시적으로 프록시 사용을 설정한다.
    - 하나의 프록시 서버만 설정 가능
    - 장애 시의 대체 작동에 대한 지원 없음
    - 조직 관리 어려움
  - 브라우저 기본 설정
  - 프락시 자동 설정  
    접근하는 문서에 따라 자바스크립트(.pac 파일)로 프록시 설정
    - 설정 방법
      1. 브라우저에 PAC 파일 URI 설정
      2. 브라우저는 PAC 파일을 읽어 모든 접근에 대해 자바스크립트를 실행해 프록시 서버 계산
  - 웹 프락시 자동발견 프로토콜 사용  
    대부분의 브라우저는 PAC 파일을 자동으로 찾아주는 알고리즘인 PWAD를 제공한다.

- **네트워크를 수정한다 (인터셉트 프락시)**  
   클라이언트는 모르게 네트워크 인프라를 가로 채서 웹 트래픽을 프락시로 가도록 조정하는 몇 가지 기법이 있다. 이를 위해선 스위칭 장치와 라우팅 장치를 필요로 한다.

- **DNS 이름 공간을 수정한다**  
   대리 프록시(리버스 프록시)는 실제 웹 서버의 이름과 IP 주소를 자신이 직접 사용하고, 실제 웹 서버의 이름과 IP 주소가 변경된다.

- **웹 서버를 수정한다**  
   웹 서버는 리다이렉션 명령을 클라이언트에 전달한다.
  > 305(Use proxy): 리소스가 반드시 프락시를 통해서 접근되어야 함을 나타내기 위해 사용한다.

<br/>

## 프락시 요청의 미묘한 특징들

### 프락시 URI는 서버 URI와 다르다

클라이언트가 서버에 요청을 보낼 땐 `스킴`과 `호스트`, `포트`가 없는 URI로 요청을 보낸다. 원래의 HTTP 설계는 단일 서버를 기준으로 작성되었기 때문에 위의 3가지 정보가 불필요한 정보라고 여겨졌기 때문이다.  
프락시가 생기면서 부분 URI에 대한 문제가 생겨났다. 프락시가 서버에 접근하기 위한 정보를 받아야하기 때문이다.  
HTTP/1.0에서 완전 URI를 보내도록 설계되었지만 기존 방식대로 부분 URI를 보내는 형태가 많이 남아있어, 프록시로는 완전 URI를 보낼 필요가 생겼다.

### 가상 호스팅에서 일어나는 같은 문제

부분 URI는 서버를 가상 호스팅하는 경우에도 문제가 생긴다.  
가상으로 호스팅되는 서버는 여러 웹 사이트가 같은 물리 서버를 가진다. 따라서 서버는 요청이 접근하고자 하는 웹 사이트에 대한 정보를 가져야한다.  
따라서 서버는 호스트와 포트에 대한 정보가 담겨 있는 Host 헤더를 요구한다.

### 인터셉트 프락시는 부분 URI를 받는다

리버스 프록시와 인터셉트 프록시가 사용될 경우 클라이언트는 자신이 프록시와 통신하고 있다고 판단하지 못하기 때문에 부분 URI를 보낼 수도 있다.

### 프락시는 프락시 요청과 서버 요청을 모두 다룰 수 있다

프락시 서버는 요청 메시지의 완전한 URI와 부분 URI를 모두 지원해야 한다.

- 완전한 URI가 주어졌다면, 프락시는 그것을 사용한다.
- 부분 URI가 주어졌고 Host 헤더가 있다면, Host 헤더를 이용해 원 서버의 이름과 포트 번호를 알아낸다.
- 부분 URI가 주어졌으나 Host 헤더가 없다면 다음 방법으로 원 서버를 알아낸다.
  - 대리 프락시라면, 프락시에 실제 서버의 주소와 포트 번호가 설정되어 있을 수 있다.
  - 인터셉트 프락시가 가로챘던 트래픽을 받았고, 그 인터셉트 프락시가 원 IP 주소와 포트번호를 사용할 수 있도록 해두었다면, 그 IP 주소와 포트번호를 사용할 수 있다.
  - 모두 실패한다면 에러 메시지를 반환한다.

### 전송 중 URI 변경

프록시는 요청으로 들어오는 URI를 수정하지 말아야한다.

### URI 클라이언트 자동확장과 호스트 명 분석

프락시가 없는 경우 브라우저는 사용자가 요청한 URI에서 IP 정보를 찾아 연결을 시도한다. 호스트가 없는 경우 호스트명을 확장하고자 아래 방법들을 시도한다.

- 일반적인 웹 사이트 이름의 가운데 부분만 입력했다면, 접두사 `www`와 접미사 `.com`을 붙인다.
- 오타 교정을 시도하고 사용자가 의도했을 URI를 제시하는 서드파티 사이트로 넘긴다.

### 명시적인 프락시를 사용할 때의 URI 분석

명시적인 프락시를 사용한다면, 브라우저는 부분 URI를 자동으로 확장하지 않는다. 사용자가 입력한 URI 그대로 프록시에 전달된다.

### 인터셉트 프락시를 이용한 URI 분석

클라이언트는 프록시를 사용하는지 알지 못하기 때문에 브라우저는 자동확장으로 URI를 분석할 수 있다. 하지만 프록시와 통신이 맺어진 후에 차이점이 있다.

- 요청을 프록시에서 원 서버로 전달하기 전에 종료한다면 클라이언트는 서버와 통신했다고 생각할 수 있지만, 실제로는 웹 서버가 살아있지도 않을 수도 있다.
- 프록시가 원서버와 통신을 시도한 결과 다운된 서버인 경우 프록시는 `장애 허용`을 제공하기 위해 host 헤더를 다시 분석하거나 역방향 DNS를 이용해 다른 IP 주소로 시도해봐야한다.

<br/>

## 메시지 추적

### Via 헤더

Via 헤더 필드는 메시지가 지나는 각 중간 노드(프락시나 게이트웨이)의 정보를 나열한다. 모든 메시지 발송자들의 프로토콜을 다루는 능력을 알아보기 위해 사용된다.

> Via: 1.1 proxy-62.irenes-isp.net, 1.0 cache.joes-hardware.com

- 문법
  - 각 노드는 `,`로 구분된다.
  - 각 노드의 프로토콜과 주소에 대한 정보를 담고 있다.
  - 프로토콜 이름  
     HTTP인 경우 생략가능 하고, 아닌 경우 버전 앞에 /로 구분하여 붙인다.
  - 프로토콜 버전  
     수신한 메시지의 프로토콜에 대한 버전을 기록한다.
  - 노드 이름  
     중개자의 호스트와 포트 번호가 담겨 있다.
- Via 요청과 응답 경로  
   요청과 응답 모두 프록시를 거치기 때문에 둘 다 Via 헤더를 갖는다.
  보통 같은 TCP 커넥션을 오가므로, 요청이 `A, B, C`를 지나간다면, 응답은 `C, B, A`를 지나간다.
- Server 헤더와 Via 헤더
  Server 헤더는 원 서버에서 사용되는 소프트웨어 정보를 담는다. 프락시는 Server 헤더를 수정하지 않고, Via 헤더를 추가한다.
- Via가 개인정보 보호와 보안에 미치는 영향  
   Via 헤더에 적힌 호스트와 포트 번호는 악의적으로 사용될 수 있기 때문에 가명을 사용하거나 조직의 통제하에 여러 노드 목록을 하나로 합칠 수 있다. 하지만 반드시 각 노드를 모두 기록하도록 노력해야한다.

### TRACE 메서드

프락시 서버는 메시지를 변형시켜 전달할 수 있다. 이는 상호운용성 문제를 유발시킬 수 있어 메시지 내용이 어떻게 변형되었는지 추적할 필요가 있다.  
TRACE 메서드는 요청 메시지가 프록시를 거치면서 어떻게 변형되는지 추적해준다.

#### Max-Forwards 헤더

Max-Forwards 헤더는 프록시 홉 개수를 제한하기 위해 사용된다. Max-Forwards 헤더 값이 `0`이라면 프록시는 더이상 다음 홉으로 전달하지 않고 클라이언트에게 반환한다. 값이 `0 이상인 경우` 1 감소된 값으로 수정하여 다음 홉에 전달한다.  
이는 전달되는 메시지가 무한 루프에 빠지지 않는지 프락시 연쇄를 테스트하거나 연쇄 중간의 특정 프락시 서버들의 효과를 체크할 때 유용하다.

<br/>

## 프락시 인증

프락시는 콘텐츠에 대한 접근 제어 장치 역할을 할 수 있다.

- 요청이 들어온 경우 `407(Proxy Authentication Required)`와 어떤 자격이 필요한지 설명해주는 `Proxy-Authenticate 헤더 필드`를 리턴한다.
- 클라이언트는 `Proxy-Authenticate 헤더`에 인증값을 넣어 다시 요청을 보낸다.

<br/>

## 프락시 상호운용성

### 지원하지 않는 헤더와 메서드 다루기

프락시는 이해하지 못하는 헤더를 그대로 다음 홉에 전달해야 한다. 같은 이름의 헤더 필드가 여러 개 있는 경우에는 그들의 상대적인 순서를 반드시 유지해야한다.  
메서드를 지원하지 않는 경우 역시 메시지를 그대로 보낼 수 있어야한다.

### OPTIONS: 어떤 기능을 지원하는지 알아보기

OPTIONS 메소드는 서버가 리소스가 어떤 기능을 제공하는지에 대한 정보를 보여준다.

> (서버 전체 기능 조회) OPTIONS \* HTTP/1.1  
> (특정 리소스 기능 조회) OPTIONS http://www.joes-hardware.com/index.html HTTP/1.1

### Allow 헤더

HTTP/1.1 이 명시한 헤더는 서버에 의해 어떤 메서드가 지원되는지 서술하는 Allow 헤더 하나뿐이다.

> Allow: GET, HEAD, PUT
