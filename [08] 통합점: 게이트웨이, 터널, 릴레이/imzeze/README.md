# 통합점: 게이트웨이, 터널, 릴레이

## 게이트웨이

게이트웨이는 리소스와 애플리케이션을 연결하는 역할을 한다.  
게이트웨이는 요청을 받고 응답하는 포털처럼 동작하는데, 동적인 콘텐츠를 생성하거나 DB에 질의를 보낼 수 있다.
또한 클라이언트에서 받은 HTTP요청을 다른 프로토콜로 변환하여 서버에 접속하기도 한다.
게이트웨이는 `<클라이언트 프로토콜>/<서버 프로토콜>`로 기술한다.

> HTTP/FTP 게이트웨이, HTTPS/HTTP 게이트웨이, H1TP/CGI 서버 측 애플리케이션 게이트웨이 등

### 클라이언트 측 게이트웨이와 서버 측 게이트웨이

웹 게이트웨이는 한쪽에서는 HTTP로, 다른 쪽에서는 HTTP가 아닌 다른 프로토콜로 통신한다.  
서버 게이트웨이는 클라이언트와 HTTP 통신을 하고, 서버와는 외래 프로토콜로 통신한다.
클라이언트 게이트웨이는 클라이언트와 외래 프로토콜로 통신하고, 서버와는 HTTP 통신을 한다.

<br />

## 프로토콜 게이트웨이

게이트웨이로 HTTP 트래픽을 바로 보낼 수 있다.

- 브라우저에 게이트웨이를 설정하여 트래픽이 게이트웨이를 거치게 한다.
  HTTP/FTP 게이트웨이를 설정한 경우, 브라우저는 HTTP 트래픽은 원 서버로 바로 전송하지만, FTP url을 포함한 요청은 게이트웨이로 HTTP 요청으로 보낸다.
- 게이트웨이를 리버스 프락시로 설정한다.

### HTTP/HTTPS:서버 측 보안 게이트웨이

클라이언트에서 보낸 HTTP요청을 암호화하여 웹서버에 HTTPS로 요청을 전달할 수 있다.

### HTTPS/HTTP:클라이언트 측 보안 가속 게이트웨이

클라이언트에서 보낸 HTTPS 요청을 복호화하여 HTTP 요청으로 만들어 서버에 보낸다. 이 게이트웨이는 원 서버보다 더 효율적으로 복호화하는 암호화 하드웨어를 내장해서 원 서버의 부담을 줄여주기도 한다. 하지만 게이트웨이와 원 서버 간의 네트워크가 안전한지 주의해야한다.

<br />
  
## 리소스 게이트웨이
게이트웨이의 가장 일반적인 형태인 애플리케이션 서버는 목적지 서버와 게이트웨이를 한 개의 서버로 결합한다. HTTP를 통해서 클라이언트와 통신하고 서버 측에 있는 애플리케이션 프로그램에 연결한다. 
> 예시   
클라이언트의 요청이 서버 게이트웨이 API를 통해 전자상거래 소프트웨어로 전송되고, 결과는 브라우저로 전송된다.

### CGI

- 애플리케이션 게이트웨이에서 유명했던 최초의 API이다.
- 서버 확장 인터페이스를 제공한다.
- 게이트웨이를 통해야하는 요청이 들어오면, 서버는 헬퍼 애플리케이션을 생성하고 헬퍼 애플리케이션은 요청을 받아 응답을 서버에 전달한다.
- 이는 웹에서 동적인 HTML, 신용카드 처리, 데이터베이스 질의 등을 제공하는 데 사용한다.
- 서버와 분리되어 다양한 언어로 개발 가능하다.
- 서버가 CGI에서 발생하는 에러에 영향을 받지 않는다.
- 요청마다 프로세스를 생성하는 데 부하가 있을 수 있다.

### 서버 확장 API

- 프로그래머가 자신의 코드를 서버에 연결하거나 서버의 컴포넌트를 자신이 만든 것으로 교체할 수 있다.
- 서버 자체의 아키텍처에 의존한다.
  > 예시  
  > 마이크로소프트, 넷스케이프, 아파치 등의 서버들은 개발자가 서버의 동작을 변경하거나 다른 리소스에 대한 사용자 맞춤 인터페이스를 제공하는 데 쓸 수 있는 API를 가진다.

<br />

## 애플리케이션 인터페이스와 웹 서비스

HTTP가 애플리케이션을 연결하면서 생기는 이슈는 데이터를 교환하려는 두 애플리 케이션 사이에서 프로토콜 인터페이스를 맞추는 일이다.  
인터넷 커뮤니티는 각 웹 애플리케이션이 서로 통신하는데 사용할 표준과 프로토콜 집합을 개발하였다.  
때문에 웹 서비스가 **독립형 웹 애플리케이션**을 의미함에도 불구하고, 그냥 그대로 웹 서비스로 불리게 되었다. 여기서 웹 서비스는 애플리케이션이 정보를 공유하는데 사용하는 새로운 메커니즘을 의미한다.  
웹 서비스는 SOAP을 통해 XML을 사용하여 정보를 교환한다.

> SOAP: HTTP, HTTPS, SMTP 등을 통해 XML 기반의 메시지를 교환하는 프로토콜  
> XML: 데이터 객체를 담는 데이터를 생성하고 해석하는 방식을 제공한다.

<br />

## 터널

- HTTP 프로토콜을 지원하지 않는 애플리케이션에 HTTP 애플리케이션을 사용해 접근하는 방법을 제공한다.
- HTTP 커넥션을 통해서 HTTP가 아닌 트래픽을 전송할 수 있다. 웹 터널을 사용하는 가장 일반적인 이유이다.
- 다른 프로토콜을 HTTP 위에 올릴 수 있다.

### CONNECT로 HTTP 터널 커넥션 맺기

웹 터널은 HTTP의 `CONNECT 메소드`를 사용하여 커넥션을 맺는다.  
`CONNECT 메소드`는 터널 게이트웨이가 임의의 목적 서버와 포트에 `TCP 커넥션`을 맺고 클라이언트와 서버 간에 오는 데이터를 무조건 전달하기를 요청한다.

1. 클라이언트가 CONNECT 요청을 보낸다.
2. CONNECT 메소드는 TCP 커넥션을 위해 게이트웨이에 터널을 요청한다.
3. TCP 커넥션이 생성된다.
4. 커넥션이 맺어지면 게이트웨이는 클라이언트에 200을 리턴한다.
5. 클라이언트와 게이트웨이 사이에 터널이 생성된다.
6. 클라이언트가 보내는 HTTP 요청이 TCP 커넥션으로 전달되며, 서버에서 보내는 데이터 역시 HTTP 터널을 통해 클라이언트에 전달된다.

### 데이터 터널링, 시간, 커넥션 관리

클라이언트는 성능을 높이기 위해 CONNECT 요청을 보낸 후, 응답을 받기 전에 터널 데이터를 전송할 수 있다. 이는 서버에 데이터를 빠르게 보내는 방법이긴 하지만, 게이트웨이가 데이터를 적절히 처리할 수 있다는 전제가 깔려있다.

게이트웨이는 터널 데이터를 확인할 수 없기 때문에 클라이언트가 보낸 모든 데이터를 그대로 받아 커넥션이 맺어지는대로 보내야한다.

터널의 끝단 어느 부분이든 커넥션이 끊어지면, 그 끊어진 곳으로부터 온 데이터는 반대편으로 전달된다. 그 다음 반대편의 커넥션도 프락시에 의해서 끊어질 것이다. 커넥션이 끊긴 한쪽에 아직 전송하지 않은 데이터는 버려진다.

### SSL 터널링

웹 터널은 원래 SSL 트래픽을 전달하기 위해 만들어졌다.  
터널을 사용하면 SSL 트래픽을 HTTP 커넥션으로 전송하여 HTTP만 허용하는 80포트의 방화벽을 통과할 수 있다.
<img width="721" alt="image" src="https://github.com/flataex/http-the-definitive-guide-study/assets/67260437/cb1e1f5c-4e74-4a82-b3a0-a4f2a3c62440">

### SSL 터널링 vs HTTP/HTTPS 게이트웨이

**HTTP/HTTPS 게이트웨이**

HTTP/HTTPS 게이트웨이가 클라이언트의 HTTPS 트랜잭션을 처리하는 방법은, 클라이언트와 게이트웨이는 HTTP 커넥션을 맺고, 게이트웨이는 HTTPS 서버와 SSL 세션을 사용하는 방식이다. HTTPS 서버로부터 받은 응답은 프록시가 복호화하여 클라이언트에 전달한다. 이 방법에는 아래 단점들이 있다.

- 클라이언트와 게이트웨이이 안전하지 않은 HTTP 커넥션으로 맺어져있다.
- 프락시가 인증을 담당하고 있어 클라이언트는 원격 서버에 인증할 수 없다.
- 게이트웨이가 SSL을 완벽히 지원해야한다.

**SSL 터널링**  
SSL 터널링을 이용하면 프락시에 SSL을 구현할 필요가 없다. SSL 세션은 클라이언트 요청과 웹 서버 간에 생성되고, 프록시는 암호화된 데이터를 그대로 터널링한다.

### 터널 인증

프락시 인증 기능을 클라이언트가 터널을 사용할 수 있는 권한을 갖는지 확인하는 용도로 사용할 수 있다.

1. 클라이언트가 게이트웨이에 CONNECT 요청을 보낸다.
2. 게이트웨이는 클라이언트에 인증을 요구한다.
3. 클라이언트가 인증과 함께 CONNECT 요청을 보낸다.
4. 게이트웨이에서 443 포트로 서버에 TCP 커넥션 요청을 보낸다.
5. 서버와 커넥션이 맺어진다.
6. 게이트웨이서 클라이언트로 200을 보낸다.

### 터널 보안에 대한 고려사항들

터널 게이트웨이는 들어오는 데이터를 검증할 방법이 없다. 터널 오용을 최소화하기 위해 게이트웨이는 특정 포트로만 터널링할 수 있도록 제한해야한다.

<br />

## 릴레이

릴레이는 커넥션을 맺기 위한 HTTP 통신을 한 다음, 맹목적으로 바이트를 전달한다. HTTP는 복잡하기 때문에 릴레이처럼 모든 헤더와 메소드를 수행하지 않고 트래픽을 전달하는 프록시 구현이 유용할 때가 있다. 하지만 이는 아래와 같은 문제점을 갖고 있다.

<img width="716" alt="image" src="https://github.com/flataex/http-the-definitive-guide-study/assets/67260437/741fd55f-0c63-4d36-ad4b-b36e46873461">

릴레이는 트래픽을 이해하지 않고 맹목적으로 전달하기 때문에 위와 같이 `Connection: Keep-Alive` 헤더를 보내놓고, 커넥션이 닫히지 않을 것으로 예상하지 않는다. 서버와 클라이언트는 커넥션이 닫히지 않은 것으로 파악하지만, 릴레이는 커넥션이 닫히기를 기다리기 때문에 클라이언트에서 보내는 다음 요청은 hang에 걸린다.

이러한 상호 운용의 문제 때문에 릴레이를 구현하고자 할 때 신중해야하며, 여러 문제를 예방하기 위해서 HTTP를 제대로 준수하는 프락시를 사용하는 게 좋다.
