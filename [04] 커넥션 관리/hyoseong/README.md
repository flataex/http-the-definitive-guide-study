# 커넥션 관리

## 4.1 TCP 커넥션

- 모든 HTTP 통신은 TCP/IP를 통해 이루어집니다.
- 브라우저가 커넥션을 맺고 끊는 과정입니다.
  ![브라우저 커넥션](./image/browser_connection.png)

### 4.1.1 신뢰할 수 있는 데이터 전송 통로인 TCP

- TCP 커넥션의 한쪽에 있는 바이트들은 반대쪽으로 순서 에 맞게 정확히 전달됩니다.

### 4.1.2 TCP 스트림은 세그먼트로 나뉘어 IP 패킷을 통해 전송된다

- TCP는 IP 패킷으로 통신합니다.
- HTTP는 ‘IP, TCP, HTTP’로 구성된 ‘프로토콜 스택’에서 최상위 계층입니다.
- HTTPS는 TLS 혹은 SSL이라 불리기도 하며 HTTP와 TCP 사이에 있는 암호화 계층입니다.
- HTTP가 메시지를 전송하고자 할 경우, 현재 연결되어 있는 TCP 커넥션을 통해서 메시지 데이터의 내용을 순서대로 보냅니다. TCP는 세그먼트라는 단위로 데이터 스트림을 잘게 나누고, 세그먼트를 IP 패킷이라고 불리는 봉투에 담아서 인터넷을 통해 데이터를 전달합니다.
- IP 패킷의 구성
  - IP 패킷 헤더(보통 20바이트)
  - TCP 세그먼트 헤더(보통 20바이트)
  - TCP데이터조각(0혹은그이상의바이트)

### 4.1.3 TCP 커넥션 유지하기

- TCP 커넥션은 4가지 값을 가지며 각 구성요소의 일부분은 같을 수 있으나 값이 모두 같을 수 없습니다.
  - 발신지 ip 주소
  - 발신지 포트
  - 수신지 ip 주소
  - 수신지 포트

### 4.1.4 TCP 소켓 프로그래밍

![socket process](./image/socket_process.png)

## 4.2 TCP의 성능에 대한 고려

### 4.2.1 HTTP 트랜잭션지연

- 지연 원인

  - 클라이언트는 URI에서 웹 서버의 IP 주소와 포트 번호를 알아내야하는데 최근에 방문한 적이 없다면 DNS 이름 분석(DNS resolution) 인프라를 사용하여 URI에 있는 호스트 명을 IP 주소로 변환하는데 수 십 초의 시간이 걸릴 수 있습니다.
  - 커넥션 설정 시간 핸드쉐이크 시간이라고도 불리며 클라이언트가 커넥션을 요청하고 회신을 기다리는 시간을 말합니다. 보통 1~2초지만 수백 개의 HTTP 트랜잭션이 만들어지면 소요시간은 크게 증가할 것입니다.
  - 커넥션이 맺어지면 TCP 파이프를 통해 전송하고 처리하는데 어플리케이션 복잡도에 따라 시간이 많이 소요됩니다.
  - HTTP 응답을 보내는 것 역시 시간이 소요됩니다.

### 4.2.2 성능 관련 중요 요소

- TCP커넥션의핸드셰이크설정
- 인터넷의 혼잡을 제어하기 위한 TCP의 느린 시작(slow-start)
- 데이터를 한데 모아 한 번에 전송하기 위한 네이글(nagle) 알고리즘
- TCP의 편승(piggyback) 확인응답(acknowledgment)을 위한 확인응답 지연 알고
  리즘
- TIME_WAIT지연과포트고갈

### 4.2.3 TCP 커넥션 핸드셰이크 지연

- 어떤 TCP 커넥션을 열든 커넥션을 맺기위해 IP 패킷을 교환합니다. 따라서 작은 크기의 데이터 전송에 커넥션이 사용된다면 HTTP 성능을 크게 저하시킬 수 있습니다.

- 커넥션 연결과정
  ![tcp connection](./image/tcp_connection.png)

SYN(synchronize), ACK(acknowledgement)

### 4.2.4 확인응답 지연

- 각 TCP 세그먼트에는 순번과 데이터 무결성 체크섬이 있습니다.
- TCP의 내부 알고리즘은 잘못 설계된 응용 프로그램으로부터 인터넷을 보호하도록 설계되었으므로 TCP 매개변수 수정은 주의해서 수행해야 합니다.
- 확인 응답 과정
  1. 수신자는 세그먼트를 성공적으로 수신하면 송신자에게 승인(ACK)을 보냅니다.
  2. 발신자가 일정 시간 내에 승인을 받지 못하면 패킷 손실 또는 오류로 간주하고 데이터를 재전송합니다.
  3. TCP는 동일한 방향으로 전송된 데이터 패킷에 대한 승인을 편승(piggyback)하여 네트워크 활용을 최적화합니다.
  4. TCP 스택은 승인 지연 알고리즘을 구현하여 편승 가능성을 높입니다.
  5. 확인 지연은 특정 시간(예: 0.1 ~ 0.2초) 동안 확인을 버퍼링하여 편승할 발신 데이터 패킷을 찾습니다.
  6. 일정 시간 내에 나가는 데이터 패킷이 발견되지 않으면 별도의 패킷으로 승인을 보냅니다.

### 4.2.5 TCP 느린 시작(slow start)

- TCP 커넥션은 시간이 지나면서 자체적으로 ‘튜닝’되어서, 처음에는 커넥션의 최대 속도를 제한하고 데이터가 성공적으로 전송됨에 따라서 속도 제한 을 높여나갑니다.

### 4.2.6 네이글(Nagle) 알고리즘과 TCP_NODELAY

- 네이글 알고리즘
  1. 전송 중인 세그먼트가 최대 크기(LAN에서 약 1,500바이트, 인터넷에서 수백 바이트)에 도달하면 즉시 전송됩니다.
  2. 다른 모든 패킷이 승인을 받은 경우 최대 크기보다 작은 패킷을 전송할 수 있습니다.
  3. 다른 패킷이 아직 전송 중이고 작은 크기의 데이터가 전송 대기 중인 경우 버퍼에 저장됩니다.
  4. 버퍼에 저장된 데이터는 확인 응답를 기다리는 패킷이 응답을 받거나 함께 전송할 수 있을 만큼의 패킷이 누적되면 전송됩니다.
- HTTP 스택에 TCP_NODELAY 파라미터 값을 설정하여 네이글 알고리즘을 비활성화도 가능합니다.

### 4.2.7 TIME_WAIT의 누적과 포트 고갈

- 2MSL은 패킷이 중복되고 TCP 데이터는 충돌을 막기위해 특정 커넥션이 생성되고 닫힌 다음, 그와 같 은 IP 주소와 포트 번호를 가지는 커넥션이 2분 이내에 또 생성되는 것을 막아줍니다.
- 일반적으로 발생하지는 않지만 스트레스테스트시 문제가 생김

## 4.3 HTTP 커넥션 관리

### 4.3.1 흔히 잘못 이해하는 Connection 헤더

- Connection 헤더에는 다음 세 가지 종류의 토큰이 전달될 수 있습니다.
  - HTTP 헤더 필드 명은, 이 커넥션에만 해당되는 헤더들을 나열합니다.
  - 임시적인 토큰 값은, 커넥션에 대한 비표준 옵션을 의미합니다.
  - close 값은, 커넥션이 작업 이 완료되면 종료되어야 함을 의미합니다.
- 홉별(hop-by-hop) 헤더
  - Connection 헤더에는 홉별헤더 명을 기술하는데, 이것은 헤더 보호하기라고 불리며 수신자는 Connection 헤더와 함께 메시지를 전달받으면, 송신자에게서 온 요청에 기술되어 있는 모든 옵션을 적용하고 다음 홉에 있는 메시지를 전달히기 전에 Connection 헤더와 Connection 헤더에 기술되 어 있던 모든 헤더를 삭제합니다.

<span style="color:gray">\* 홉이란 요청 또는 응답이 클라이언트와 서버 사이를 통과하는 각 중간 네트워크 노드 또는 서버입니다.</span>

### 4.3.2 순차적인 트랜잭션 처리에 의한 지연

- 동기적으로 커넥션을 맺으면 매우 비효울적입니다. 예를들어 3개의 이미를 불러오는 페이지를 랜더링할떄 html, image1, image2, image3 4번의 커넥션이 맺어지고 동기적으로 처리하게되면 굉장히 느리게 화면을 보게됩니다.
- 병렬(parallel) 커넥션
  여러 개의 TCP 커넥션을 통한 동시 HTTP 요청
- 지속(persistent) 커넥션
  커넥션을 맺고 끊는 데서 발생하는 지 연을 제거하기 위한 TCP 커넥션의 재활용
- 파이프라인(pipelined) 커넥션
  공유 TCP 커넥션을 통한 병렬 HTTP 요청
- 다중(m니tiplexed) 커넥션
  요청과 응답들에 대한 중재(실험적인 기술이다)

## 4.4 병렬 커넥션

![parallel connection](./image/parallel_connection.png)

### 4.4.1 병렬 커넥션은 페이지를 더 빠르게 내려받는다

### 4.4.2 병렬 커넥션이 항상 더 빠르지는 않다

- 클라이언트의 네트워크 대 역폭이 좁을 때 제한된 대역폭 내에서 각 객체를 전송받는 것은 느리기 때문에 성능상의 장점은 거의 없어집니다.
- 다수의 커넥션은 메모리를 많이 소모하고 자체적인 성능 문제를 발생을 시킵니다.
- 브라우저는 실제로 병렬 커넥션을 사용하긴 하지만 적은 수(대부분 4개)의 병 렬 커넥션만을 허용합니다.

### 4.4.3 병렬 커넥션은 더 빠르게 ‘느껴질 수’ 있다

- 사람들은 페이지의 총 다운로드 시간이 더 걸린다 하더라도, 화면 전체에서 여러 작업이 일어나는 것을 눈으로 확인할 수 있으면 그 것을 더 빠르다고 느낍니다,

### 4.5 지속 커넥션

- 사이트 지역성
  - 서버에 HTTP 요청을 하기 시작한 애플리케이션 은 웹페이지 내의 이미지 등을 가져오기 위해서 그 서버에 또 요청하는 것
  - 지원하는 기기는 처리가 완료된 후 에도 TCP 커넥션을 유지하여 앞으로 있을 HTTP 요청에 재사용할 수 있습니다.
  - 처리가 완료된 후에도 계속 연결된 상태로 있는 TCP 커넥션을 지속 커넥션이라고 부릅니다.

### 4.5.1 지속 커넥션 vs 병렬 커넥션

- 병렬 커넥션 단점

  - 각 트랜잭션마다 새로운 커넥션을 맺고 끊기 때문에 시간과 대역폭이 소요
  - 각각의 새로운 커넥션은 TCP 느린 시작 때문에 성능하락
  - 실제로 연결할 수 있는 병렬 커넥션의 수의 제한

- 병렬 커넥션에 비해 지속 커넥션의 장점

  - 커넥션을 맺기 위한 사전 작업과 지 연을 줄여주고, 튜닝 된 커넥션 유지

- 지속 커 넥션은 병 렬 커넥션과 함께 사용될 때에 가장 효과적입니다.

- -지속 커넥션 타입
  - keep-alive 커넥션
  - persistnet 커넥션

### 4.5.2 HTTP/1.0+°| Keep-Alive 커넥션

### 4.5.3 Keep-Alive 동작

- HTTP/1.1 명세에서 빠짐
- 아직도 브라우저와 서버 간에 keep-alive 핸드셰이크가 널리 사용되고 있음
- Connection:Keep-Alive 헤더를 포함시켜서 사용

### 4.5.4 Keep-Alive 옵션

- 클라이언트나 서 버가 keep-alive 요청을 받았다고 해서 무조건 그것을 따를 필요는 없고 keep-alive 커넥션을 끊을 수 있으며 keep-alive 커넥션에서 처 리되는 트랜 잭션의 수를 제한할 수도 있습니다.
- 옵션
  - timeout : 얼마 간 유지될 것인지를 의미
  - max : 커넥션이 몇 개의 HTTP 트랜잭션을 처리할 때까지 유지될 것인지를 의미
  - Keep-Alive 헤더 : 이름[=값] 같은 식으로 임의 의 속성들을 지원

### 4.5.5 Keep-Alive 커넥션 제한과 규칙

- 기본으로 사용되지는 않음
- 커넥션이 끊어지기 전에 엔터티 본문의길이 를알수 있어야 커넥션을 유지
- 클라이언트는 응답 전체를 모두 받기 전에 커넥션이 끊어졌을 경우, 별다른 문 제가 없으면 요청을 다시 보낼 수 있게 준비되어 있어야 합니다.

### 4.5.6 Keep-Alive와 멍청한(dumb) 프락시

- 프락시는 Connection 헤더를 이해하지 못해 서 해당 헤더들을 삭제하지 않고 요청 그대로를 다음 프락시에 전달하기에 행(hang)이 걸릴 수 있는 위험이 있습니다.

### 4.5.7 Proxy-Connection 살펴보기

- Proxy-Connection 확장 헤더를 프록시에게 전달하고 프록시가 Proxy-Connection 헤더를 무조건 전달하더라도 웹 서버는 그것을 무시하기 때문에 별문제가 되지 않습니다. 하지만 영리한 프록시(지속 커넥션 핸드셰이킹을 이해할 수 있는)라면, 의미 없는 Proxy-Connection 헤더를 Connection 헤더로 바꿈으로써 원하던 효과를 얻을 수 있습니다.

![proxy conncetion](./image/proxy_conncetion.png)

### 4.5.8 HTTP/1.1 의 지속 커넥션

- HTTP/1.1 에서는 keep-alive 커넥션을 지원하지 않는 대신, 설계가 더 개선된 지속 커넥션을 지원합니다.
- HTTP/1.1 에서는 별도 설정을 하지 않는 한, 모든 커넥션을 지속 커넥션으로 취급합니다.

### 4.5.9 지속 커넥션의 제한과 규칙

- 클라이언트가 요청에 Connection: close 헤더를 포함해 보냈으면, 클라이언트는 그 커넥션으로 추가적인 요청을 보낼 수 없음
- 클라이언트가 해당 커넥션으로 추가적인 요청을 보내지 않을 것이라면, 마지막 요청 에 Connection: close 헤더를 보내야 함
- 모든메시지가자신의길이정보를정확히가지고있을때에만커 넥션을 지속시킬 수 있음
- 하나의 사용자 클라이언트는 서버의 과부하를 방지하기 위해서, 넉넉잡아 두 개의 지속 커넥션만을 유지해야 함

## 4.6 파이프라인 커 넥션

- HTTP/1.1은 지속 커넥션을 통해서 요청을 파이프라이닝할 수 있으며 여러 개의 요청은 응답이 도착하기 전까지 큐에 쌓고 순차적으로 처리합니다. 대기 시간이 긴 네트워크 상황에서 네트워크상의 왕복으로 인한 시간을 줄여서 성능을 높여줍니다.

![transition condition](./image/transition%20condition.png)

## 4.7 커넥션 끊기에 대한 미스터리

- 커넥션 관리(특히 언제 어떻게 커넥션을끊는가)에는 명확한 기준이 없습니다.

### 4.7.1 ‘마음대로’커넥션끊기

### 4.7.2 Content-Length와 Truncation

- 클라이언트나 프락시가 커넥션이 끊어졌다는 HTTP 응답을 받은 후, 실제 전달된 엔티티 의 길이와 Content-Length의 값이 일치하지 않거나 Content-Length 자체 가 존재하지 않으면 수신자는 데이터의 정확한 길이를 서버에게 물어봐야 합니다.

### 4.7.3 커넥션 끊기의 허용, 재시도, 멱등성

- 한 번 혹은 여러 번 실행됐는지에 상관없이 같은 결과를 반환한다면 그 트랜잭션(GET, HEAD, PUT, DELETE, TRACE, OPTIONS)은 메서드들은 멱등합니다.
- 클라이언트는 POST와 같이 멱 등인 아닌 요청은 파이프라인을 통해 요청하면 안 됩니다. 전송 커넥 션이 예상치 못하게 끊어져 버 렸을 때, 알 수 없는 결과를 초래할 수 있기 떄문입니다.
- 비멱등인 메서드나 순서에 대해 에이전트가 요청을 다시 보낼 수 있도록 기능을 제공한다 하더라도, 자동으로 재시도하면 안 되고 다시 보내기를 원하는 지 묻는 대화상자를 보여주는 식으로 개발하여야합니다.

### 4.7.4 우아한 커넥션 끊기

- 전체 끊기와 절반 끊기
  - 전체 끊기 : closeO를 호출하면 TCP 커넥션의 입력 채널과 출력 채널의 커넥션을 모두 끊습니다.
  - 절반 끊기 : 입력 채널이나 출력 채널 중에 하나를 개별적으로 끊으려면 shutdown을 호출합니다.
- TCP 끊기와 리셋 에러

  - 프락시와 통신할 때, 그리고 그들과 파이 프라인 지속 커넥션을 사용할 때 절발 끊기를 사용하며, 클라이언트에서 더는 데이터를 보내지 않을 것임을 확신할 수 없는 이상, 커넥션 의 입력 채널을 끊는 것은 위험합니다.

  ![connection reset](./image/connection_reset.png)

  - 연결이 끊겼을 때 데이터를 읽으려 하면, connection reset by peer 에러를 받게 될 것 이고, 응답 데이터가 기기에 잘 도착하였어도 아직 읽히지 않은 버퍼에 있는 응답 데이터는 사라지게 됩니다.

- 애플리케이션 자신의 출력 채널을 먼저 끊고 다른 쪽에 있는 기기의 출력 채널이 끊기는 것을 기다리는 것입니다.
- 양쪽에서 더는 데이터를 전송하지 않을 것이라고 알려주면 커넥션은 리셋 없이 온전히 종료됩니다.
