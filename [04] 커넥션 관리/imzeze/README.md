# 커넥션 관리

## TCP 커넥션

HTTP 통신은 TCP/IP 연결을 통해 이루어진다. TCP 특성에 따라 일단 연결이 되면, 클라이언트와 서버 컴퓨터 간에 주고받는 메시지들은 손실되거나 순서가 바뀌지 않고 안전하게 전달된다는 특징이 있다.

1. TCP 스트림은 세그먼트로 나뉘어 IP 패킷을 통해 전송된다

<img width="710" alt="image" src="https://github.com/flataex/http-the-definitive-guide-study/assets/67260437/6dd630e3-8b5c-4a82-9b48-4e878dbd4a9d">

HTTP는 TCP 커넥션을 통해 전송하고자 하는 데이터를 순서에 맞게 보내고, TCP는 데이터를 세그먼트 단위로 나눠 IP 패킷을 담아 데이터를 전송한다.

> IP 패킷 구성은 다음과 같다.

- IP 헤더  
  발신지, 목적지 IP 주소 등
- TCP 세그먼트 헤더  
  TCP 포트 번호, TCP 제어 플래그, 데이터의 순서와 무결성을 검사하기 위해 사용되는 숫자 값
- TCP데이터조각

2.  TCP 커넥션 유지하기
    > TCP 커넥션 구성
        <발신지 ip 주소, 발신지 포트, 수신지 ip 주소, 수신지 포트>

위 네가지 값으로 유일한 커넥션을 유지한다.

3. TCP 소켓 프로그래밍  
   **socket api 인터페이스**

<br />

## TCP의 성능에 대한 고려

HTTP는 TCP 바로 위에 있는 계층이기 때문에 HTTP 트랜잭션의 성능은 그 아래 계층인 TCP 성능에 영향을 받는다.

1.  HTTP 트랜잭션 지연  
    HTTP 트랜잭션을 지연시키는 원인은 여러 가지가 있다. 이는 하드웨어, 네트워크, 메시지의 크기 등에 영향을 받는다.
    - DNS 이름 분석을 사용해 URI에 있는 호스트 명을 IP 주소로 변환하는 데 시간이 걸린다.
    - 클라이언트는 TCP 커넥션 요청을 서버에게 보내고 서버가 커넥션 허가 응답을 회신하기를 기다린다.
    - TCP 커넥션이 연결되면 클라이언트는 TCP 파이프를 통해 HTTP 요청을 보내고, 서버는 데이터가 도착하는 대로 TCP 커넥션에서 요청 메시지를 읽고 처리하는 데 시간이 걸린다.
    - 웹 서버가 HTTP 응답을 보내는 것 역시 시간이 소요된다.
2.  성능 관련 중요 요소

    ### TCP 커넥션 핸드셰이크 지연

    [커넥션 단계]

    1. 클라이언트가 TCP 패킷을 서버에 보낸다. 이 패킷은 `SYN` 플래그를 갖는다. `SYN` 플래그는 커넥션 생성 요청을 뜻한다.
    2. 서버는 커넥션 요청을 받아들인다는 `ACK` 플래그와 클라이언트에도 허용을 요청하는 `SYN` 플래그를 보낸다.
    3. 클라이언트는 커넥션 요청을 받아들인다는 `ACK` 플래그를 보낸다.

    크기가 작은 HTTP 트랜잭션은 50% 이상의 시간을 TCP를 구성하는 데 쓴다.

    ### 확인 응답 지연

    각 TCP 세그먼트는 순번과 데이터 무결성 checksum을 갖는다.  
     [확인 응답]

    1. 세그먼트를 받은 수신자는 확인응답 패킷을 송신자에게 보낸다.
    2. 만약 송신자가 특정 시간동안 확인응답을 받지 못한 경우 오류가 있는 것으로 판단하고 데이터를 다시 전송한다.

    확인 응답은 크기가 작기 때문에 송출될 데이터 패킷이 있다면, 데이터 패킷에 편승되어 보내진다. 당장 송출될 데이터 패킷이 없다면 0.1초 ~ 0.2초 정도 Buffer에 저장해 송출될 데이터 패킷을 찾는다. 그래도 송출될 데이터 패킷을 못 찾으면 별도의 패킷을 생성하여 송신자에게 전달된다. 이를 확인 응답 지연이라고 한다.

    ### TCP 느린 시작

    TCP가 한 번에 전송할 수 있는 패킷의 수를 제한하고, 전송에 성공한 경우 윈도우를 늘려 나간다. 이 기능 때문에 새로운 커넥션은 기존의 커넥션보다 속도가 느리다.

    ### 네이글(Nagle) 알고리즘과 TCP_NODELAY

    네이글 알고리즘은 네트워크 효율을 위해서, 패킷을 전송하기 전에 많은 양의 TCP 데이터를 한 개의 덩어리로 합친다. 이 크기가 최대가 되지 않으면 전송하지 않고 buffer에 저장한다. buffer에서 최대 크기만큼 쌓이거나 다른 모든 패킷이 확인 응답을 받았을 경우, 확인 응답을 기다리던 패킷이 확인응답을 받은 경우에 buffer에 저장된 데이터가 전송된다.

         [문제점]

         - 크기가 작은 패킷은 최대 크기만큼 쌓이기 위해 그 만큼의 대기가 걸린다.
         - 확인응답 지연 알고리즘과 함께 쓰일 경우 확인 응답 대기까지 더해져 더 오랜 시간이 소요된다.

    HTTP 애플리케이션은 성능 향상을 위해서 HTTP 스택에 TCP_NODELAY 파라 미터 값을 설정하여 네이글 알고리즘을 비활성화하기도 한다.

    ### TIME_WAIT의 누적과 포트 고갈

    ![image](https://github.com/flataex/http-the-definitive-guide-study/assets/67260437/0d0b02d9-ca12-48bf-89d9-ca35e8b763ed)

    `TIME_WAIT` 상태는 TCP 커넥션의 마지막 단계로, TCP 커넥션을 끊으면 커넥션의 IP 주소와 포트 번호를 메모리에 기록해 놓는다. 이 정보는 같은 주소와 포트 번호를 사용하는 새로운 TCP 커넥션이 일정 시간 동안에는 생성되지 않게 하기 위한 것이다.  
    `TIME_WAIT` 상태에서 마지막 패킷(ACK)이 제대로 전송이 되었는지를 확인하는데, 제대로 전송되지 않았을 경우 상대에서 다시 ACK, FIN 메시지를 보낸다.  
    `TIME_WAIT` 상태가 있기 때문에 이전 커넥션과 관련된 패킷이 그 커넥션과 같은 주소와 포트 번호를 가지는 새로운 커넥션에 삽입되는 문제를 방지할 수 있다.
    클라이언트가 접속할 때마다 새로운 커넥션을 생성한다면, 사용할 수 있는 포트 수는 정해져있고 `TIME_WAIT` 상태의 커넥션이 누적되어 있기 때문에 `TIME_WAIT` 포트 고갈 현상이 나타날 수 있다.

  <br />

## HTTP 커넥션관리

1. 흔히 잘못 이해하는 Connection 헤더  
   HTTP Connection 헤더 필드는 `커넥션 토큰`을 쉼표로 구분하여 가지고 있으며, 여기에 있는 토큰은 다음 커넥션에 전달되지 않는다. 특정 두 서버 간에 영향을 미치기 때문에 hop-by-hop(홉별) 헤더명을 기술한다고도 한다.

   <img width="396" alt="image" src="https://github.com/flataex/http-the-definitive-guide-study/assets/67260437/f726cccf-e543-4159-9d3c-395716d5a63d">

   다음 홉 (hop)에 메시지를 전달하기 전에 Connection 헤더와 Connection 헤더에 기술되어 있던 모든 헤더를 삭제한다. 따라서 위와 같은 값을 가질 때, `meter`는 다음 커넥션에 전달되지 않고, 트랜잭션이 끝나면 커넥션이 끊긴다.

2. 순차적인 트랜잭션 처리에 의한 지연  
   n개의 리소스를 받을 때 n개의 HTTP 트랜잭션을 만들어 순차적으로 처리하는 방식은 커넥션을 생성하는 지연과, slow-start 지연을 만든다. 이런 지연을 해결하기 위해 다음 방법을 사용할 수 있다.

- 병렬 커넥션
- 지속 커넥션
- 파이프라인 커넥션
- 다중 커넥션
