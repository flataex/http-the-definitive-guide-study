# 커넥션 관리

## TCP 커넥션

HTTP 통신은 TCP/IP 연결을 통해 이루어진다. TCP 특성에 따라 일단 연결이 되면, 클라이언트와 서버 컴퓨터 간에 주고받는 메시지들은 손실되거나 순서가 바뀌지 않고 안전하게 전달된다는 특징이 있다.

1. TCP 스트림은 세그먼트로 나뉘어 IP 패킷을 통해 전송된다

<img width="710" alt="image" src="https://github.com/flataex/http-the-definitive-guide-study/assets/67260437/6dd630e3-8b5c-4a82-9b48-4e878dbd4a9d">

HTTP는 TCP 커넥션을 통해 전송하고자 하는 데이터를 순서에 맞게 보내고, TCP는 데이터를 세그먼트 단위로 나눠 IP 패킷을 담아 데이터를 전송한다.

> IP 패킷 구성은 다음과 같다.

- IP 헤더  
  발신지, 목적지 IP 주소 등
- TCP 세그먼트 헤더  
  TCP 포트 번호, TCP 제어 플래그, 데이터의 순서와 무결성을 검사하기 위해 사용되는 숫자 값
- TCP데이터조각

2.  TCP 커넥션 유지하기
    > TCP 커넥션 구성
        <발신지 ip 주소, 발신지 포트, 수신지 ip 주소, 수신지 포트>

위 네가지 값으로 유일한 커넥션을 유지한다.

3. TCP 소켓 프로그래밍  
   **socket api 인터페이스**

<br />

## TCP의 성능에 대한 고려

HTTP는 TCP 바로 위에 있는 계층이기 때문에 HTTP 트랜잭션의 성능은 그 아래 계층인 TCP 성능에 영향을 받는다.

1.  HTTP 트랜잭션 지연  
    HTTP 트랜잭션을 지연시키는 원인은 여러 가지가 있다. 이는 하드웨어, 네트워크, 메시지의 크기 등에 영향을 받는다.
    - DNS 이름 분석을 사용해 URI에 있는 호스트 명을 IP 주소로 변환하는 데 시간이 걸린다.
    - 클라이언트는 TCP 커넥션 요청을 서버에게 보내고 서버가 커넥션 허가 응답을 회신하기를 기다린다.
    - TCP 커넥션이 연결되면 클라이언트는 TCP 파이프를 통해 HTTP 요청을 보내고, 서버는 데이터가 도착하는 대로 TCP 커넥션에서 요청 메시지를 읽고 처리하는 데 시간이 걸린다.
    - 웹 서버가 HTTP 응답을 보내는 것 역시 시간이 소요된다.
2.  성능 관련 중요 요소

    ### TCP 커넥션 핸드셰이크 지연

    [커넥션 단계]

    1. 클라이언트가 TCP 패킷을 서버에 보낸다. 이 패킷은 `SYN` 플래그를 갖는다. `SYN` 플래그는 커넥션 생성 요청을 뜻한다.
    2. 서버는 커넥션 요청을 받아들인다는 `ACK` 플래그와 클라이언트에도 허용을 요청하는 `SYN` 플래그를 보낸다.
    3. 클라이언트는 커넥션 요청을 받아들인다는 `ACK` 플래그를 보낸다.

    크기가 작은 HTTP 트랜잭션은 50% 이상의 시간을 TCP를 구성하는 데 쓴다.

    ### 확인 응답 지연

    각 TCP 세그먼트는 순번과 데이터 무결성 checksum을 갖는다.  
     [확인 응답]

    1. 세그먼트를 받은 수신자는 확인응답 패킷을 송신자에게 보낸다.
    2. 만약 송신자가 특정 시간동안 확인응답을 받지 못한 경우 오류가 있는 것으로 판단하고 데이터를 다시 전송한다.

    확인 응답은 크기가 작기 때문에 송출될 데이터 패킷이 있다면, 데이터 패킷에 편승되어 보내진다. 당장 송출될 데이터 패킷이 없다면 0.1초 ~ 0.2초 정도 Buffer에 저장해 송출될 데이터 패킷을 찾는다. 그래도 송출될 데이터 패킷을 못 찾으면 별도의 패킷을 생성하여 송신자에게 전달된다. 이를 확인 응답 지연이라고 한다.

    ### TCP 느린 시작

    TCP가 한 번에 전송할 수 있는 패킷의 수를 제한하고, 전송에 성공한 경우 윈도우를 늘려 나간다. 이 기능 때문에 새로운 커넥션은 기존의 커넥션보다 속도가 느리다.

    ### 네이글(Nagle) 알고리즘과 TCP_NODELAY

    네이글 알고리즘은 네트워크 효율을 위해서, 패킷을 전송하기 전에 많은 양의 TCP 데이터를 한 개의 덩어리로 합친다. 이 크기가 최대가 되지 않으면 전송하지 않고 buffer에 저장한다. buffer에서 최대 크기만큼 쌓이거나 다른 모든 패킷이 확인 응답을 받았을 경우, 확인 응답을 기다리던 패킷이 확인응답을 받은 경우에 buffer에 저장된 데이터가 전송된다.

         [문제점]

         - 크기가 작은 패킷은 최대 크기만큼 쌓이기 위해 그 만큼의 대기가 걸린다.
         - 확인응답 지연 알고리즘과 함께 쓰일 경우 확인 응답 대기까지 더해져 더 오랜 시간이 소요된다.

    HTTP 애플리케이션은 성능 향상을 위해서 HTTP 스택에 TCP_NODELAY 파라 미터 값을 설정하여 네이글 알고리즘을 비활성화하기도 한다.

    ### TIME_WAIT의 누적과 포트 고갈

    ![image](https://github.com/flataex/http-the-definitive-guide-study/assets/67260437/0d0b02d9-ca12-48bf-89d9-ca35e8b763ed)

    `TIME_WAIT` 상태는 TCP 커넥션의 마지막 단계로, TCP 커넥션을 끊으면 커넥션의 IP 주소와 포트 번호를 메모리에 기록해 놓는다. 이 정보는 같은 주소와 포트 번호를 사용하는 새로운 TCP 커넥션이 일정 시간 동안에는 생성되지 않게 하기 위한 것이다.  
    `TIME_WAIT` 상태에서 마지막 패킷(ACK)이 제대로 전송이 되었는지를 확인하는데, 제대로 전송되지 않았을 경우 상대에서 다시 ACK, FIN 메시지를 보낸다.  
    `TIME_WAIT` 상태가 있기 때문에 이전 커넥션과 관련된 패킷이 그 커넥션과 같은 주소와 포트 번호를 가지는 새로운 커넥션에 삽입되는 문제를 방지할 수 있다.
    클라이언트가 접속할 때마다 새로운 커넥션을 생성한다면, 사용할 수 있는 포트 수는 정해져있고 `TIME_WAIT` 상태의 커넥션이 누적되어 있기 때문에 `TIME_WAIT` 포트 고갈 현상이 나타날 수 있다.

  <br />

## HTTP 커넥션관리

1. 흔히 잘못 이해하는 Connection 헤더  
   HTTP Connection 헤더 필드는 `커넥션 토큰`을 쉼표로 구분하여 가지고 있으며, 여기에 있는 토큰은 다음 커넥션에 전달되지 않는다. 특정 두 서버 간에 영향을 미치기 때문에 hop-by-hop(홉별) 헤더명을 기술한다고도 한다.

   <img width="396" alt="image" src="https://github.com/flataex/http-the-definitive-guide-study/assets/67260437/f726cccf-e543-4159-9d3c-395716d5a63d">

   다음 홉 (hop)에 메시지를 전달하기 전에 Connection 헤더와 Connection 헤더에 기술되어 있던 모든 헤더를 삭제한다. 따라서 위와 같은 값을 가질 때, `meter`는 다음 커넥션에 전달되지 않고, 트랜잭션이 끝나면 커넥션이 끊긴다.

2. 순차적인 트랜잭션 처리에 의한 지연  
   n개의 리소스를 받을 때 n개의 HTTP 트랜잭션을 만들어 순차적으로 처리하는 방식은 커넥션을 생성하는 지연과, slow-start 지연을 만든다. 이런 지연을 해결하기 위해 다음 방법을 사용할 수 있다.

- 병렬 커넥션
- 지속 커넥션
- 파이프라인 커넥션
- 다중 커넥션

<br/>

## 병렬 커넥션

HTTP는 클라이언트가 여러 개의 커넥션을 맺음으로써 여러 개 의 HTTP 트랜잭션을 병렬로 처리할 수 있게 한다.

### 병렬 커넥션은 페이지를 더 빠르게 내려받는다

<img width="791" alt="image" src="https://github.com/flataex/http-the-definitive-guide-study/assets/67260437/c8f220a7-ef47-43df-9549-ce4223209714">
<img width="782" alt="image" src="https://github.com/flataex/http-the-definitive-guide-study/assets/67260437/52016b64-1076-415d-8380-e0cfe891e8a7">

병렬 커넥션은 각 커넥션의 지연 시간을 겹치게 하여 **총 지연 시간**을 줄일 수 있다.

### 병렬 커넥션이 항상 더 빠르지는 않다

네트워크의 대역폭이 좁은 경우 대부분 객체를 다운로드 받는 데에 쓰이고, 여러 커넥션을 생성하는 것 자체로도 부하가 올 수 있기 때문에 병렬 커넥션이 더 느릴 수도 있다. 커넥션은 많은 메모리를 소모하기도 해서 브라우저는 클라이언트의 최대 커넥션 개수를 보통 4개로 제한한다.

### 병렬 커넥션은 더 빠르게 ‘느껴질 수’ 있다

직렬 커넥션은 한 객체씩 처리되는 것을 볼 수 있지만, 병렬 커넥션은 여러 객체가 동시에 처리되는 것을 확인할 수 있기 때문에 클라이언트는 훨씬 빠르다고 느낄 수 있다.

<br/>

## 지속커넥션

> **지역성이란** 최근에 사용했던 메모리를 그리고 해당 메모리 인근을 접근할 가능성이 높다는 의미이다.

한 웹사이트에 접속하여 데이터를 받아올 때, 연결된 서버에서 다음 데이터를 받아올 가능성이 높다. 따라서 커넥션을 유지하여 앞으로 있을 HTTP 요청을 보낼 수 있다. 처리가 완료된 후에도 연결 상태로 남아있는 커넥션을 `지속 커넥션`이라고 한다. 지속 커넥션은 서버나 클라이언트가 커넥션을 끊어 버리기 전까지 유지된다.  
지속 커넥션을 사용함으로써 연결 지연이나 느린 시작 지연을 피할 수 있으며 커넥션 수를 줄일 수 있다.

### 지속 커넥션 vs 병렬 커넥션

병렬 커넥션은 다음 문제점이 있다.

1. 각 트랜잭션마다 새로운 커넥션을 맺고 끊기 때문에 시간과 대역폭이 소모된다.
2. 각각의 새로운 커넥션은 느린 시작 지연이 생긴다.
3. 실제로 맺어지는 병렬 커넥션 개수는 제한적이다.

지속 커넥션은 다음의 문제점이 있다.

1. 커넥션이 잘못 관리될 경우 연결되어 있는 커넥션 수가 증가해 클라이언트와 서버에 불필요한 소모를 발생시킨다.

요즘 대부분의 애플리케이션은 병렬 커넥션과 지속 커넥션을 함께 사용해 효과적으로 커넥션을 관리한다. 적은 수의 병렬 커넥션을 만들고 이 커넥션들을 지속시키는 방법이다. HTTP/1.0+ 에서는 `keep-alive 커넥션` 타입이 있고, HTTP/1.1에서는 `지속 커넥션` 타입이 있다.

### HTTP/1.0+의 Keep-Alive 커넥션

<img width="791" alt="image" src="https://github.com/flataex/http-the-definitive-guide-study/assets/67260437/c8f220a7-ef47-43df-9549-ce4223209714">
<img width="745" alt="image" src="https://github.com/flataex/http-the-definitive-guide-study/assets/67260437/8d6ed120-53f9-492c-a5dd-574de600397e">

각 트랜잭션마다 커넥션을 만들지 않고 하나의 지속 커넥션으로만 처리하는 방식으로, 커넥션을 맺고 끊는데 필요한 작업이 없어서 시간이 단축된다. 또한, 느린 시작이 일어나지 않기 때문에 요청 및 응답 시간도 줄어든다.

### Keep-Alive 동작

클라이언트는 커넥션을 유지하기 위해서 요청에 `Connection: Keep-Alive` 헤더를 포함시킨다.  
이 요청을 받은 서버는 그 다음 요청도 이 커넥션을 통해 받고자 한다면, 응답 메시지에 같은 헤더를 포함시켜 응답한다. 만약 응답 메시지에 같은 헤더가 없다면 클라이언트는 서버가 Keep-Alive를 지원하지 않으며 현재 커넥션이 끊길 것으로 판단한다.

### Keep-Alive 옵션

- timeout
  커넥션이 얼마나 유지될 것인지 설정한다.
- max
  몇 개의 트랜잭션을 처리할 때까지 유지될 것인지 설정한다.
  > ex) Keep-Alive: max=5, timeout=120  
  > 5개의 트랜잭션을 처리하거나 120초 동안 유지되어야 한다.

Keep-Alive 헤더는 단순히 커넥션을 유지하기 위한 요청일 뿐 클라이언트나 서버는 이 요청을 반드시 처리할 필요가 없다. 따라서 위의 옵션을 설정하여도 지켜지지 않을 수 있다.

### Keep-Alive 커넥션 제한과 규칙

- 커넥션이 끊기기 전에 엔터티 본문의 크기를 알 수 있어야 커넥션을 유지할 수 있다. 따라서 엔터티 본문이 정확한 `Content-Length`와 `Content-Type`을 갖거나 chunked transfer encoding으로 인코딩되어야 한다. 정확한 값이 아닐 경우 트랜잭션의 맺고 끊음이 불명확해진다.
  > chunked transfer encoding
  >
  > - HTTP/1.1에서 가능한 데이터 스트리밍 전송 방식
  > - 데이터가 조각(chunk)으로 나누어져 전송되며, 마지막으로 길이가 0인 chunk가 전송되면서 끝이난다.
  > - 따라서 Content-Length 값이 없다.
- 프락시나 게이트웨이는 다음 커넥션으로 Connection 헤더를 보내지 말아야한다.
- Keep-Alive 커넥션은 Connection 헤더를 인식하지 못하는 프락시와 맺어지면 안된다.
  > 아래 **Keep-Alive와 멍청한(dumb) 프락시** 참고
- HTTP/1.0 버전의 애플리케이션에서 오는 Connection 헤더는 무시되어야한다.
- 클라이언트는 모든 응답을 받기 전에 커넥션이 끊길 경우 다시 요청을 보낼 준비가 돼 있어야한다.

### Keep-Alive와 멍청한(dumb) 프락시

Connection 헤더를 이해하지 못해 hop-by-hop 원칙을 따르지 않고 다음 서버에 Connection 헤더를 전송하면서 문제가 발생한다.

1. 클라이언트가 `Connection: Keep-Alive`헤더를 포함해 요청을 보낸다.
2. 프락시는 Connection 헤더를 이해하지 못해 Connection 헤더를 삭제하지 않고 서버에 그대로 전달한다.
3. 서버는 `Connection: Keep-Alive` 요청을 받아드려 응답 헤더에 같은 헤더를 포함시켜 보낸다.
4. 프락시는 이번에도 Connection 헤더를 삭제하지 않고 클라이언트에 그대로 전달한다.
5. 클라이언트는 커넥션 지속 요청이 받아드려진 것으로 판단하고, 같은 커넥션으로 새 요청을 보낸다.
6. 프락시는 응답이 끝났기 때문에 서버가 커넥션을 끊기를 기다리지만, 서버는 커넥션을 끊지 않는다.
7. 클라이언트가 보낸 새로운 요청은 프락시에서 무시되어 타임아웃이나 커넥션이 끊길 때까지 기다리게 된다.

### Proxy-Connection 살펴보기

Connection 헤더를 이해하지 못하고 그대로 전송하는 문제점을 해결하기 위해 `Proxy-Connection`이 생겼다. `Proxy-Connection` 요청은 프락시에 따라 무시될 수도 있고, 받아드려질 수도 있다.

**무시되는 경우**

1. 클라이언트는 프락시와의 연결을 지속하기 위해 `Proxy-Connection: Keep-Alive` 헤더를 보낸다.
2. 프락시는 서버에 `Proxy-Connection: Keep-Alive` 헤더를 그대로 보낸다.
3. 서버는 이 헤더를 무시하고 응답 메시지를 보낸다. 따라서 Connection 헤더가 없다.
4. 프락시 역시 Connection 헤더가 없는 응답 메시지를 클라이언트에 보낸다.

**받아드려지는 경우**

1. 클라이언트는 프락시와의 연결을 지속하기 위해 `Proxy-Connection: Keep-Alive` 헤더를 보낸다.
2. 프락시는 Proxy-Connection 헤더를 Connection 헤더로 바꿔 `Connection: Keep-Alive`로 서버에 보낸다.
3. 서버는 프락시의 지속 요청을 받아드려 프락시에 `Connection: Keep-Alive` 헤더를 포함해 응답 메시지를 보낸다.
4. 프락시 역시 클라이언트에 지속 요청을 받아드린다는 의미로 `Connection: Keep-Alive`를 포함시켜 전달한다.

따라서 클라이언트는 프락시와, 프락시는 서버와 커넥션을 유지할 수 있다.  
이 방식은 클라이언트와 서버 사이에 한 개의 프락시만 있는 경우에서만 동작한다.

### HTTP/1.1 의 지속 커넥션

HTTP/1.1은 Keep-Alive 커넥션을 지원하지 않는 대신, 지속 커넥션을 기본적으로 지원하며, 연결을 끊기 위해 `Connection: close` 헤더를 명시해야 한다.  
하지만 `Connection: close`를 보내지 않는 것이 서버가 커넥션을 영원히 유지하겠다는 것을 뜻하지는 않는다. 언제든지 클라이언트나 서버는 커넥션을 끊을 수 있다.

### 지속 커넥션의 제한과 규칙

- 커넥션을 지속시키기 위해 정확한 `Content-Length`와 `Content-Type`을 갖거나 chunked transfer encoding으로 인코딩되어야 한다.
- 프락시는 클라이언트와 서버 각각에 대해 별도의 지속 커넥션을 맺고 관리해 야 한다.
- 클라이언트는 모든 응답을 받기 전에 커넥션이 끊길 경우 다시 요청을 보낼 준비가 돼 있어야한다.
- 서버 과부하를 막기 위해 클라이언트는 최대 2개의 지속 커넥션을 맺도록 한다.

<br/>

## 파이프라인커넥션

<img width="747" alt="image" src="https://github.com/flataex/http-the-definitive-guide-study/assets/67260437/a2e26a68-488c-484c-96f8-712f91b49b01">

지속 커넥션에서 들어오는 요청을 병렬적으로 처리하는 것을 파이프라인 커넥션이라고 한다.  
파이프라인 커넥션은 다음 제약사항이 있다.

- 응답이 요청 순서와 맞게 전달되어야한다.
- POST 요청과 같이 반복해서 보낼 경우 문제가 되는 요청(비멱등 요청)은 파이프라인을 통해 전달해선 안된다.

<br/>

## 커넥션 끊기에 대한 미스터리

커넥션 관리에는 명확한 기준이 없다.

### ‘마음대로’ 커넥션 끊기

클라이언트, 서버, 프락시 서버는 언제든지 커넥션을 끊을 수 있다.
보통 메시지를 모두 보낸 후 커넥션을 끊지만, 에러가 나거나 클라이언트가 유휴 상태에 있으면 서버는 커넥션을 끊을 수 있다. 이 때 클라이언트는 요청 메시지를 보내는 도중에 문제가 생길 수도 있다.

### Content-Length와 Truncation

일부 오래된 HTTP 서버는 응답 메시지를 모두 보내면 커넥션을 모두 끊도록 설계되었기 때문에 Content-Length 값을 보내지 않는 경우도 있었다.  
클라이언트나 프락시 서버는 엔터티의 길이와 응답 메시지의 Content-Length 값이 다르거나 Content-Length 값이 없으면 데이터의 정확한 길이를 서버에 확인해 봐야한다.

### 우아한 커넥션 끊기

TCP 커넥션은 양방향 커넥션으로, 각 종단에는 큐가 있다. 출력 큐에 있는 데이터는 입력 큐에 전달된다.

**전체 끊기와 절반 끊기**  
`close()`를 호출 하면 입력 채널과 출력 채널 모두 끊을 수 있다.  
`shutdown()`은 입력 채널이나 출력 채널 중 하나를 개별적으로 끊을 수 있다.

**TCP 끊기와 리셋 에러**  
파이프라인 커넥션을 사용할 경우 절반 끊기를 사용하는 것이 안전하다.
특히 출력 채널을 끊는 것이 안전하다. 메시지를 받는 곳
은 버퍼에 쌓인 데이터를 모두 읽은 후 커넥션이 끊긴 것을 확인할 수 있다.  
입력 채널이 끊긴 상태에서 메시지를 보낼 경우 운영체제는 에러로 인식하고, 버퍼에 쌓인 아직 읽히지 않은 데이터를 모두 삭제한다.

**우아하게 커넥션 끊기**  
우아한 커넥션 끊기는 `자신의 출력 채널을 먼저 끊고 상대편이 출력 채널을 끊기까지 기다리는 것`이다.
