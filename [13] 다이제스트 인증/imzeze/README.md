# 다이제스트 인증

## 다이제스트 인증의 개선점

다이제스트 인증은 기본 인증의 결함을 수정한 HTTP 인증 프로토콜이다.

다이제스트 인증 역시 완전히 안전한 프로토콜은 아니다. 안전한 HTTP 트랜잭션을 위한 많은 요구사항을 충족시키기 위해선 전송 계층 보안 `TLS`와 `HTTPS`가 더 적합한 프로토콜이다.

> **TLS(Transport Layer Security)**
>
> 정보를 암호화해서 송수신하는 프로토콜  
> 서버 및 클라이언트의 신원을 확인하는 데에는 인증 기관에서 발급된 인증서가 사용된다.  
> TLS를 사용해 암호화된 연결을 하는 HTTP를 HTTPS라고 한다.

다이제스트 인증의 특징은 아래와 같다.

- 비밀번호를 평문으로 전송하지 않는다.
- 인증 체결을 가로채지 못하도록 차단한다.
- 메시지 내용 위조를 막는 것도 가능하다.

### 비밀번호를 안전하게 지키기 위해 요약 사용하기

클라이언트는 비밀번호를 뒤섞은 _fingerprint_ 또는 *요약*을 보낸다. 클라이언트와 서버는 둘 다 비밀번호를 알고 있으므로, 서버는 클라이언트가 보낸 요약이 비밀번호에 알맞게 대응하는지 검사할 수 있다.

<img width="709" alt="image" src="https://github.com/flataex/http-the-definitive-guide-study/assets/67260437/d8be1428-760e-4c9d-9bef-5a01de256b1c">

1. 클라이언트가 인증이 필요한 문서를 요청한다.
2. 서버는 클라이언트에게 이름과 비밀번호를 요청한다.
3. 클라이언트는 비밀번호 요약을 서버에 전달한다.
4. 서버는 내부 계산한 비밀번호 요약과 클라이언트가 제공한 비밀번호 요약이 같은지 비교한다.

### 단방향 요약

요약은 단방향 함수로 동작한다. 단방향 함수는 임의의 길이를 갖는 데이터를 고정 길이의 압축으로 변환한다. 요약함수는 보통 `암호 체크섬`이라고 불린다.

<img width="698" alt="image" src="https://github.com/flataex/http-the-definitive-guide-study/assets/67260437/c0a8c5a6-3c60-4ccb-8fe1-19964ee74109">

> **양방향 암호화와 단방향 암호화**
>
> 양방향 암호화는 암호화한 데이터를 복호화할 수 있는 것을 말한다. 대칭키, 공개키 암호화 방식이 이에 속한다. 단방향 암호화는 암호화한 데이트를 복호화할 수 없는 것을 말한다. 대표적으로 hash 함수가 있다.

### 재전송 방지를 위한 난스(nonce) 사용

단방향 요약을 통해 비밀번호가 복호화될 위험성을 해결할 수 있지만, 복호화된 비밀번호를 가로채 재전송할 수 있다는 위험성이 남아있다.

이런 재전송 공격을 방지하기 위해 서버는 클라이언트에 `난스`를 보낸다. 난스는 자주 바뀌는 값으로, 난스를 비밀번호화 섞으면 난스가 바뀔 때마다 요약도 바뀌게 된다. 특정 난스 값에서만 비밀번호가 유효하기 때문에 재전송 공격을 막을 수 있다.

난스는 WWW-Authenticate 인증 요구에 담겨서 서버에서 클라이언트로 넘겨진다.

### 다이제스트 인증 핸드셰이크

HTTP 다이제스트 인증 프로토콜은 기본 인증과 비슷한 헤더를 사용한다.  
<img width="676" alt="image" src="https://github.com/flataex/http-the-definitive-guide-study/assets/67260437/ff8d71bb-27ef-4b0a-a514-6e9b8b37fbdd">

1. 서버는 `WWW-Authenticate` 헤더에 다이제스트 인증이 필요한 사실과, `realm`, `qop(Quality of Protection-보안등급)`, `nonce` 값을 보낸다.
2. 클라이언트는 `Authorization` 헤더에 인증에 필요한 정보를 요약한 `response`와 서버에서 보낸 헤더값 등을 보낸다. 만약 클라이언트가 서버를 인증하고자 한다면 클라이언트 난스를 보낼 수 있다.
3. 서버는 클라이언트로부터 받은 값들을 이용해 요약을 구하고, 클라이언트가 보낸 요약과 일치하는지 판단한다.

<br/>

## 요약 계산

다이제스트 인증의 핵심은 공개된 정보, 비밀 정보, 시한부 난스 값을 조합한 단방향 요약이다.

### 요약 알고리즘 입력 데이터

요약은 다음의 세 요소로부터 계산된다.

- 단방향 해시함수 `H(d: data)`와 요약함수 `KD(s: secret, d: data)`
- 비밀번호 등 보안 정보; `A1`
- 요청 메시지의 비밀이 아닌 속성을 담고 있는 데이터; `A2`

### H(d)와 KD(s,d) 알고리즘

다이제스트 인증은 여러 알고리즘을 사용할 수 있으며 기본값은 `MD5`(Message Digest 5)이다. MD5를 사용하면 단방향 해시함수와 요약함수는 아래와 같다.

- H(d) = MD5(d)
- KD(s,d) = H(s:d) = MD5(s:d)

### 보안 관련 데이터 (A1)

A1에는 사용자 이름, 비밀번호, realm, nounce 등이 있다.  
RFC 2617은 선택된 알고리즘에 따라 A1을 계산할 수 있는 두가지 방법을 정의
한다.

- MD5  
   A1 = 〈사용자〉:〈영역〉:〈비밀번호〉  
   모든 요청마다 단방향 해시를 실행한다.
- MD5-sess  
  A1 = MD5(〈사용자〉:〈영역〉:〈비밀번호〉):〈난스〉:〈클라이언트난스〉

### 메시지 관련 데이터 (A2)

A2는 메시지 본문, 메소드, URL 등 메시지 정보를 나타낸다.  
A2는 메서드, 리소스, 메시지의 위조를 방지하기 위해 사용된다.  
A2 사용법은 qop에 따라 다르다.

- qop=“auth” 또는 qop이 정의되지 않은 경우
  〈요청 메서드〉:〈uri 지시자 값〉
- qop=“auth-int”  
   〈요청 메서드>:〈uri 지시자 값〉:H(〈요청 엔터티 본문〉)

### 요약 알고리즘 전반

H, KD, Al, K2로 요약을 계산하는 방법

- qop이 정의되지 않은 경우 (deprecated)  
   KD(H(A1), 〈난스〉:H(A2)) = MD5(MD5(A1):〈난스〉:MD5(A2))
- qop="auth" 또는 qop="auth-int"  
   난스 횟수 집계 및 대칭 인증의 지원을 포함한다.  
  KD(H(A1), 〈난스〉:〈난스횟수〉:〈클라이언트난스〉:〈보안등급〉:H(A2))  
  = MD5(MD51:〈난스〉:〈난스횟수〉:〈클라이언트난스〉:〈보안등급〉:MD5(A2))

### 다이제스트 인증 세션

WWW-Authenticate 인증 요구에 대한 클라이언트 응답은 인증 세션을 시작하게 한다.  
인증 세션은 다른 서버로부터 또 다른 WWW-Authenticate 인증 요구를 받을 때까지 지속된다.
클라이언트는 사용자 이름, 비밀번호, 난스, 난스 횟수, Authorization 헤더에 들어갈 값 등을 갖고 있어야한다.  
서버는 만료된 난스도 받아드릴지, 401과 새로운 난스를 보내 응답할지 정해야한다.  
다만 `stale=true`를 클라이언트에 보내 새로운 요청에서 사용자 이름과 비밀번호는 다시 받지 않고 새로운 난스만 받을 수 있다.

### 사전(preemptive) 인가

만약 클라이언트가 다음 난스가 무엇이 될지 미리 알고 있어서, 올바른 Authorization 헤더를 생성할 수 있다면 요청/인증요구 사이클을 생략할 수 있다.  
다만 서버는 임의의 난스를 생성하기 때문에 클라이언트는 인증요구를 받기 전까진 어떤 Authorization 헤더가 올바른지 알 수 없다.  
이를 해결할 수 있는 방법은 아래와 같다.

- 서버가 다음 난스를 Authentication-Info 성공 헤더에 담아서 미리 보낸다.
- 서버가 짧은 시간 동안 같은 난스를 재사용하는 것을 허용한다.
- 클라이언트와 서버가 동기화되어 있고 예측 가능한 난스 생성 알고리즘을 사용
  한다.

### 다음 난스 미리 생성하기

다음 난스를 미리 보내게 되면 서버의 다중 요청을 파이프라이닝하는 능력은 쓸모 없어지게 된다. 다음 요청을 보내기 전에 반드시 다음 난스 값을 받아야 하기 때문이다.

#### 제한된 난스 재사용

난스를 미리 생성하는 방법 대신에 난스를 제한적으로 재사용하는 것을 허용하는 방법도 있다. 이 경우 다중 요청을 파이프라이닝할 수 있다. 하지만 재전송 공격의 위험성이 남아있다.

#### 동기화된 난스 생성

클라이언트와 서버가 비밀키를 갖고 있으면서 순차적으로 같은 난스를 생성할 수 있도록 동기화된 알고리즘을 사용하는 방법도 가능하다.

### 난스 선택

난스의 내용은 불투명하고 구현 의존적이다.

> 제안된 난스 공식
>
> BASE64(타임스탬프H(타임스탬프:ETag:개인키))

- 타임스탬프  
   서버에서 생성된 시간 혹은 반복 불가능한 값
  난스의 유효 기간을 제한할 수 있다.
- ETag  
   요청된 엔터티에 대한 ETag 헤더값
  갱신된 리소스에 대한 재요청을 방지한다.
- 개인키: 서버만이 알고 있는 값

### 상호 인증

`클라이언트 난스(c난스)` 값을 제공함으로써 클라이언트가 서버를 인증할 수 있다.  
상호 인증은 qop 지시자가 존재할 때는 항상 수행하여야 하고, 없다면 수행하지 말아야 한다.

응답 요약은 메시지 본문 정보(A2)가 다르다는 것만 제외하면 요청 요약과 같은 방법으로 계산할 수 있다. 메시지 본문 정보(A2)가 다른 이유는, 응답에는 HTTP 메서드라는 것이 없고 요청과 응답의 메시지 엔터티 데이터가 서로 다르기 때문이다.  
서버는 이 요약을 Authentication-1nfo 헤더를 통해 클라이언트에 전달한다.

A2 계산

- qop=“auth” 또는 qop이 정의되지 않은 경우
  :〈uri 지시자 값〉
- qop=“auth-int”  
  :〈uri 지시자 값〉:H(응답 엔터티 본문〉)

응답 계산

- qop="auth" 또는 qop="auth-int"  
  MD5(MD51:〈난스〉:〈난스횟수〉:〈클라이언트난스〉:〈보안등급〉:MD5(A2))

<br />

## 보호 수준(Quality of Protection) 향상

qop 필드는 WWW-Authenticate, Authorization, Authentication-Info에 모두 존재할 수 있다.  
qop 필드는 클라이언트와 서버가 어떤 보호 기법을 어느 정도 수준으로 사용할 것인지 협상할 수 있게 해준다.

- 서버는 WWW-Authenticate 헤더에 qop 옵션 목록을 담아 클라이언트에 보낸다.
- 클라이언트는 그 옵션들 중 하나를 선택해 Authorization 헤더에 담아 서버에 보낸다.

> **auth와 auth-init**
>
> auth: 인증
> auth-init: 인증 및 메시지 무결성 보호

### 메시지 무결성 보호

<img width="375" alt="image" src="https://github.com/flataex/http-the-definitive-guide-study/assets/67260437/273f2c90-8e71-4219-b8e4-db0da7b643a6">

qop=“auth-int” 일 때 엔터티 본문의 해시값이 구해진다.

<br />

## 실제 상황에 대한 고려

### 다중 인증 요구

서버는 한 리소스에 대해 여러 인증을 요구할 수 있다. 다중 인증 요구를 받았을 때 클라이언트는 반드시 자신이 지원할 수 있는 가장 강력한 인증 메커니즘을 선택해야 한다.

WWW-Authenticate나 Proxy-Authenticate에 인증요구가 둘 이상 포함되거나 WWW-Authenticate 헤더가 둘 이상 제공될 수도 있다.

서버는 기본 인증을 받았을 때 제한적인 부분만 처리할 수 있도록 처리해야하며 여러 시스템에서 같은 비밀번호를 사용하는 것의 위험성을 경고해야한다.

### 오류 처리

- 지시자나 그 값이 적절하지 않은 경우 `400`을 리턴한다.
- 요청의 요약이 맞지 않으면, 실패 했음을 기록해 두는 것이 좋다.
  반복된 실패는 공격자가 비밀번호 추측을 시도하고 있음을 의미한다.
- 서버는 ‘uri’ 지시자가 가리키는 리소스가 요청줄에 명시된 리소스와 같음을 확인해야 한다.

### 보호 공간(Protection Space)

realm 값은 root url과 더해져 보호공간을 나타낸다.

#### 영역

- 영역 값은 일반적으로 원 서버에 의해 할당되는 문자열이다.
- 인증 제도에 추가적인 의미를 더한다.
- 영역은 다른 다중 인증요구가 있을 수 있다.

#### 보호공간

- 어떤 자격이 자동으로 적용되는 영역을 결정한다.
- 이전 요청이 인가 되면, 같은 자격은 정해진 시간 동안 재사용될 것이다.
- 기본인증에서 클라이언트는 요청 URI와 그 하위의 모든 경로는 같은 보호공간에 있는 것으로 가정한다.
  클라이언트는 이 공간에서 서버로부터의 또 다른 인증 요구를 기다리지 않고 미리 리소스에 대한 인가를 받을 수 있다.
- 다이제스트 인증에서 인증요구의 `WWW-Authenticate: domain` 필드는 보호공간을 보다 엄밀하게 정의한다.

### URI 다시 쓰기

프락시는 가리키는 리소스의 변경 없이 구문만 고쳐서 URI를 다시 쓰기도 한다.

- 호스트 명은 정규화되거나 IP 주소로 대체될 수 있다.
- 문자들은 “%” escape 형식으로 대체될 수 있다.
- 타입에 대한 추가 속성이 URI의 끝에 붙거나 중간에 삽입될 수 있다.

프락시가 URI를 변경할 수 있는 동시에 다이제스트 인증은 URI 값의 무결성을 검사하므로, 다이제스트 인증은 이러한 변경에 의해 실패할 수 있다.

### 캐시

어떤 공유 캐시가 Authorization 헤더를 포함한 요청과 그에 대한 응답을 받은 경우, 다음의 두 Cache-Control 지시자 중 하나가 응답에 존재하지 않는 한 다른 요청에 대해 그 웅답을 반환해서는 안된다.

- Cache-Control: must-revalidate  
   원 서버가 새 요청을 인증할 수 있도록, 우선 그 요청의 헤더를 이용해서 재검사를 수행해야 한다.
- Cache-Control: public
  다음 요청에 대한 응답으로 반환할 수 있다.

> Cache-Control: must-revalidate
>
> 캐시 만료 후 최초 조회시 원 서버에 검증해야 할 때 설정한다. 원 서버에 접근이 불가한 경우 캐시된 사본을 클라이언트에 제공하지 않고, `504(Gateway Timeout error)`를 반환한다.

<br />

## 보안에 대한 고려사항

### 헤더 부당 변경

헤더 변경을 막기 위해 양 종단의 암호화나 헤더에 대한 디지털 서명이 필요하다.

### 재전송 공격

서버가 재전송된 자격을 승인해버렸다는 것은, 틀림없이 같은 난스 값을 반복해 서 사용한 것이다. 이 문제를 완화시키는 방법 중 하나는 클라이언트의 IP 주소, 타임스탬프, 리소스의 ETag, 개인 서버 키에 대한 요약을 포함하는 난스를 서버가 생성하도록 하는 것이다.

하지만 클라이언트의 IP를 사용하게 되면, 다른 프락시를 통과하게 될 수도 있는 프락시 팜은 사용할 수 없게 된다. 또한 IP 주소를 속이는 것도 그다지 어려운 일이 아니다.

재전송 공격을 막는 방법은 트랜잭션마다 유일한 난스 값을 사용하는 것이다.

### 사전(dictionary) 공격

사전 공격은 전형적인 비밀번호 추측 공격이다.  
사용자가 상대적으로 단순한 비밀번호를 사용하고 서버도 단순한 난스를 사용하고 있다면 맞는 것을 찾아낼 확률이 꽤 있다.  
이 문제를 해결할 좋은 방법은, 크래킹하기 어렵도록 상대적으로 복잡한 비밀번 호를 사용하는 것과 괜찮은 비밀번호 만료 정책 외에는 실질적으로 없다.

### 악의적인 프락시와 중간자 공격(Man-in-the-Mid세e Attack)

클라이언트 요청이 이동하는 여러 프락시 중 보안이 약하거나 악의적인 프락시가 있다면 클라이언트는 중간자 공격에 취약한 상태가 될 가능성이 있다.

이를 해결하기 위해 SSL을 사용하거나 클라이언트가 언제나 가능한 한 가장 강력한 인증을 선택하도록 설정하는 것등이 있다.

### 선택 평문 공격

클라이언트에게 난스를 제공하고 받은 암호화된 값을 바탕으로 복호화키를 찾는 공격이다.
선택 평문 공격에는 몇 가지 변종이 있다.

#### 미리 계산된 사전 공격

공격 서버는 난스와 자주 쓰이는 비밀번호들로 사전을 만든다. 그 후 클라이언트에 난스를 보내고, 받은 응답 값을 사전에서 조회한다. 만약 대응 되는 것이 있다면 공격 서버는 클라이언트의 비밀번호를 얻은 것이다.

#### 자동화된 무차별 대입 공격

미리 계산된 비밀번호를 토대로 찾는 것이 아니라 많은 컴퓨터를 동원해 주어진 범위에서 가능한 모든 비밀번호를 열거해서 찾는다.

이 두 방법을 해결하는 방법은 클라이언트 난스를 사용하는 것이다. 여기에 강력한 비밀번호와 정책을 사용해 위협을 완전히 경감시킬 수 있다.

### 비밀번호 저장

다이제스트 인증 메커니즘은 사용자 응답을 서버 내부에 저장된 것과 비교한다. 때문에 비밀번호 파일이 유출되면 영역의 모든 문서는 즉각 공격자에게 노출된다.  
이 문제를 완화하는 몇 가지 방법은 다음과 같다.

- 비밀번호 파일을 안전히 보관한다.
- 영역으로 국소화한다.
