# 클라이언트 식별과 쿠키

## 개별 접촉

HTTP 특징

- 익명이며 서버가 클라이언트의 상태를 갖고 있지 않다.(stateless)
- 웹서버는 요청을 보낸 사용자를 식별하거나 요청을 추적하기 위해 정보를 요구할 수 있다. 이는 개인화 서비스를 지원하는 데 용이하다.
  - 개별인사
  - 사용자 맞춤 추천
  - 사용자 정보를 저장해 서비스 로직 단순화
  - 세션 추적

> **Stateless의 장점**
>
> Stateless는 연결 자체에 대한 정보를 가지지 않으며 모든 요청이 일회성이고 독립적으로 처리된다는 것을 의미한다.
>
> 클라이언트의 상태를 갖고 요청을 처리중이던 서버에서 장애가 난다면, 다른 서버는 클라이언트의 상태를 갖고 있지 않기 때문에 장애가 난 서버 대신 클라이언트에 응답을 보내기 어렵다.
>
> Stateless하다면, 클라이언트는 어느 서버에 요청을 보내든 동일한 응답을 받을 수 있을 것이다. 따라서 Stateless하다는 것은 서버 확장이 용이하다는 의미이기도 하다.

<br />

## HTTP 헤더

일반적으로 사용자에 대한 정보를 전달하는 데에 쓰이는 헤더는 아래와 같다.

| 헤더            | 설명                                     |
| --------------- | ---------------------------------------- |
| From            | 사용자의 이메일 주소                     |
| User-Agent      | 사용자의 브라우저                        |
| Referer         | 사용자가 현재 링크를 타고 온 근원 페이지 |
| Authorization   | 사용자 인증                              |
| Client-ip       | 클라이언트 IP 주소                       |
| X-Forwarded-For | 클라이언트 IP 주소                       |
| Cookie          | 서버가 생성한 ID 라벨                    |

- From  
  잘 사용되지 않는 헤더. 크롤러가 장애 보고를 받기위해 보내는 경우는 있다.
- User-Agent  
  특정 브라우저에 최적화된 컨텐츠를 제공하기 위해 받는다.
- Referer  
  사용자의 취향 파악에 도움이 되기도 한다.

<br />

## 클라이언트 IP 주소

클라이언트 IP로 사용자를 식별하기에는 다음과 같은 문제점이 있어 잘 사용되지 않는다.

- 동일한 컴퓨터를 사용하는 여러 사용자를 식별할 수 없다.
- ISP가 사용자에게 동적 IP를 할당할 수 있다.
- 네트워크 주소 변환 방화벽을 사용하는 인터넷망 안에 있는 사용자라면, 사용자의 실제 IP 주소를 받을 수 없다.
- 프락시나 게이트웨이를 사용하는 경우 서버는 클라이언트의 IP 대신 프락시나 게이트웨이의 IP를 받게 된다.

<br />

## 사용자 로그인

`Authorization` 헤더는 서버가 사용자에게 식별 인증을 요구하는 방법이다.  
 사용자를 식별할 수 없을 때 서버는 `401` 상태코드를 반환하고,  
사용자는 로그인 후에 보내는 모든 요청의 헤더에 `Authorization`을 보내 서버가 항상 로그인 정보를 확인할 수 있게 한다.

<br />

## 뚱뚱한 URL

사용자를 식별하기 위해 URL에 상태 정보를 추가하는 경우도 있다.  
사용자가 그 사이트를 돌아다니면, 웹 서버는 URL에 있는 상태 정보를 유지하는 하
이퍼링크를 동적으로 생성한다.  
이 방법은 독립적인 트랜잭션을 하나의 세션으로 묶을 수 있지만 아래와 같은 문제점이 있다.

- 사용자와 세션에 대한 정보가 담겨있는 이 URL을 다른 사람과 공유하는 경우 개인정보도 노출된다.
- URL이 바뀌기 때문에 기존 캐시를 사용할 수 없다.
- 사용자가 사이트를 이동하면서, 상태 정보가 초기화될 수도 있다.
- 로그인하면 모든 정보를 잃는다.

<br />

## 쿠키

### 쿠키의 타입

쿠키 타입에는 파기 시점에 따라 `세션 쿠키`와 `지속 쿠키`로 나뉜다.
세션 쿠키는 휘발성이 있는 임시 쿠키로, 브라우저가 닫히면 날라간다.  
지속 쿠키는 디스크에 저장되어 브라우저를 닫거나 컴퓨터를 다시 시작해도 남아있다.  
Discard라는 파라미터가 설정되어 있거나, 파기까지 남은 시간인 Expires 또는 Max-Age라는 파라미터가 없으면 세션쿠키이다.

### 쿠키는 어떻게 동작하는가

웹서버는 key-value 형태의 쿠키를 `Set-Cookie`나 `Set-Cookie2` 헤더에 넣어 클라이언트로 보낸다.  
브라우저는 서버로부터 받은 쿠키 컨텐츠를 브라우저 쿠키 데이터베이스에 저장하고, 이후 모든 요청 헤더의 `Cookie`에 이 값을 넣어 보낸다.

### 사이트마다 각기 다른 쿠키들

브라우저는 갖고 있는 모든 쿠키를 각 사이트에 보내지 않는다.

- 모든 쿠키를 보내는 것은 성능 저하를 일으킨다.
- 특정 서버에서만 인식할 수 있는 key-value이기 때문에 다른 사이트로 전송하는 것이 무의미하다.
- 특정 사이트에서 제공한 정보를 다른 사이트로 제공함으로써 개인정보 문제가 생길 수 있다.

보통 브라우저는 쿠키를 생성한 서버에만 쿠키를 담아 요청을 보낸다.

### 쿠키 구성요소

### Version 0(넷스케이프) 쿠키

넷스케이프에서 정의한 쿠키 명세에는 `Set-Cookie`와 `Cookie`, 쿠키 속성이 있다.

```
Set-Cookie: name=value [; expires=date] [; path=path] [; domain=domain] [; secure]
```

- expires
  ```
  Set-Cookie: foo=bar;
  expires=Wednesday, 09-Nov-99 23:12:40 GMT;
  ```
  expires에 설정된 날짜가 지나면 쿠키는 삭제되고, 브라우저에 전달되지 않는다. expires가 명시되지 않았다면 사용자의 세션이 만료될 때 삭제된다.
- domain
  ```
  Set-cookie: user=mary;
  domain="airtravelbargains.com";
  ```
  위와 같이 서버에서 쿠키를 보낼 때, domain을 보내면 브라우저는 이에 해당하는 모든 도메인에 요청을 보낼 때 쿠키를 포함해서 보낸다.
- path
  ```
  Set-cookie: pref=conpact;
  domain="airtravelbargains.com";
  path=/autos/;
  ```
  path 값을 설정해 브라우저에 보내면, 특정 문서에만 쿠키를 보낼 수 있다. 위와 같이 보낸 경우 `www.airtravelbargains.com/autos/*`의 경로에만 `pref="conpact"` 쿠키가 전달된다.
- secure
  ```
  Set-Cookie: private_id=519; secure
  ```
  HHTP가 SSL 보안 연결을 사용할 때만 쿠키를 전송한다.

```
Cookie: namel=value1 [; name2=value2] ...
```

Cookie 헤더는 위에서 설정된 값(expires, domain, path, secure)에 일치할 때 서버에 보내진다.

### 쿠키 역사

<img width="616" alt="image" src="https://github.com/flataex/http-the-definitive-guide-study/assets/67260437/e9dfcbac-5dba-4a56-ad92-6bc5fb886281">

넷스케이프 쿠키를 시작으로 제한 사항을 강화한 `RFC2109`, Set-cookie2 스펙을 제시한 `RFC2965`가 나왔다. `RFC2109`와 `RFC2965`는 잘 사용되지 않았고, HTML5가 나오면서 새로운 스펙을 강제하기보다 브라우저와 웹 서버들의 관행을 문서화하는 데에 집중한 `RFC6265`가 나타났다.

RFC6265와 version 0 쿠키 사이 차이점은 아래와 같다.

<img width="899" alt="image" src="https://github.com/flataex/http-the-definitive-guide-study/assets/67260437/a944a002-0a62-4567-a282-0ee894ab3dd8">

### 쿠키와 캐싱

쿠키 트랜잭션과 관련있는 콘텐츠를 캐싱하는 것은 위험하다. 개인정보 노출의 위험이 있기 때문이다. 캐시를 할 때 주의점은 아래와 같다.

- 캐시 비허용 표시를 한다.  
  `Cache-Control` 헤더를 이용해 캐시를 제어한다.
- Set-Cookie 헤더를 캐시하는 것에 유의해야한다.
- Cookie를 갖고 있는 요청에 주의한다.

 <br />

---

#### Referer

[HTTP쿠키와 톰캣 쿠키 프로세서 이야기](https://meetup.nhncloud.com/posts/209)
