# 웹 서버

- HTTP 및 그와 관련된 TCP 처리를 구현한 것이다.
- 리소스에 대한 HTTP 요청을 받아서 콘텐츠를 클라이언트에게 돌려준다.
- 웹 리소스를 관리하고, 서버 관리 기능을 제공한다.
- TCP 커넥션을 관리한다.

<br/>

## 단계 1: 클라이언트 커넥션 수락

### 클라이언트 호스트명 식별

웹 서버는 `역 DNS`를 이용해 클라이언트의 IP를 클라이언트 호스트명으로 변환할 수 있다. 이 작업은 꽤 시간이 걸릴 수 있기 떄문에 웹 트랜잭션을 느리게 할 수 있다.

### ident를 통해 클라이언트 사용자 알아내기

몇몇 웹서버는 IETF ident 프로토콜을 지원한다.  
클라이언트가 ident 프로토콜을 지원한다면, 서버는 HTTP 커넥션 요청이 들어올 때 ident 서버 포트(113)번으로 ident 커넥션을 맺고 클라이언트의 이름을 묻는 요청을 보낸다. 사용자 이름은 로깅에 유용하게 쓰인다.

<br/>

## 단계 2: 요청 메시지 수신

커넥션에 데이터가 들어오면, 웹서버는 데이터를 파싱하여 요청 메시지를 구성한다.

### 메시지의 내부 표현

몇몇 서버는 파싱한 메시지를 사용하기 편리하고 접근하기 쉬운 형태로 파싱해 내부 자료구조에 저장한다.

### 커넥션 입력/출력 처리 아키텍처

**단일 스레드 웹 서버**  
한 번에 하나의 요청만 처리한다. 트랜잭션이 완료되면 다음 커넥션이 처리된다.

**멀티프로세스와 멀티스레드 웹 서버**  
여러 요청을 한 번에 처리하기 위해 여러 개의 프로세스 혹은 고성능 스레드를 할당한다. 수많은 멀티프로세스나 멀티스레드는 메모리 및 리소스를 소비하기 때문에 많은 웹 서비스들이 최대 개수를 제한하고 있다.

![image](https://github.com/flataex/http-the-definitive-guide-study/assets/67260437/b8b4929a-6cec-4ba5-9cdf-421edc3f3441)

> 가장 먼저 실행되는 부모 프로세스를 fork 해서 자식 프로세스를 생성한다.

<img width="687" alt="image" src="https://github.com/flataex/http-the-definitive-guide-study/assets/67260437/bf0aa5e4-9c6d-4b1a-be25-9b6bd148ec95">

> 하나의 프로세스 안에 다수의 스레드가 존재한다. 하나의 스레드에 문제가 생기면 다른 스레드에도 영향을 미칠 수 있다.

**다중 I/O 서버**  
하나의 통신 채널을 통해서 둘 이상의 데이터(시그널)를 전송하는 방법이다.

> [select]  
> select 함수를 호출해 각 커넥션의 상태 변화를 감지하고, 차례대로 처리된다.
> <img width="425" alt="image" src="https://github.com/flataex/http-the-definitive-guide-study/assets/67260437/7c16056a-b7eb-4af0-bb4d-a2633fa0f913">

**다중 멀티스레드 웹 서버**  
여러 개의 스레드에서 각각 커넥션의 변화를 감지하고 처리하는 방식이다.

<br/>

## 단계 3:요청처리

<br/>

## 단계 4: 리소스의 매핑과 접근

### Docroot

가장 단순한 리소스 매핑 방법은 URI를 웹서버 파일 시스템의 파일 이름으로 사용하는 것이다. 일반적으로 웹 컨텐츠를 저장하는 폴더를 만들어 두는데, 이 폴더를 `docroot` 라고 부른다.

> 설정 ) DocumentRoot /usr/local/httpd/files  
> 요청 URI ) /specials/saw-blade.gif
>
> DocumentRoot 설정값이 위와 같고, 아래 요청이 들어온 경우 서버는 /usr/local/httpd/files/specials/saw—blade.gif 리소스를 반환한다.

가상 호스팅하여 요청 URI에 따라 다른 docroot를 갖도록 설정할 수도 있다.

### 디렉터리 목록

웹서버는 특정 파일이 아닌 디렉토리를 가리키는 요청을 받았을 때, 일반적으로 `index` 파일을 찾아 반환한다.

### 동적 콘텐츠 리소스 매핑

웹서버는 컨텐츠를 생성하는 프로그램에 매핑해 동적 리소스를 반환할 수도 있다.

### 서버사이드 인클루드(Server-Side Includes, SSI)

SSI가 포함된 웹 페이지를 서버에 요청했을 때, SSI는 서버에서 실행되고 완성된 코드를 클라이언트에 보낸다.

<br/>

## 단계 5:응답 만들기

### 응답 엔터티

트랜잭션이 응답 본문을 생성한다면, 그 내용을 응답 메시지와 함께 돌려보낸다.  
• 응답 본문의 MIME 타입을 서술하는 Content-Type 헤더  
• 웅답 본문의 길이를 서술하는 Content-Length 헤더  
• 실제 응답 본문의 내용

### MIME 유형 결정하기

**파일 확장자**  
파일의 확장자를 서버 MIME 타입 테이블에서 탐색하여 반환한다.  
**매직 타이핑**  
파일이 표준 확장자 없이 이름 지어진 경우에 유용한 방법으로, 파일의 내용을 검사해서 특정 패턴으로 MIME 유형을 찾아 리턴한다.  
**유형 명시**  
서버에서 유형을 명시하여 확장자나 내용에 관계없이 특정 유형으로 리턴할 수 있다.
**유형 협상**  
사용자와의 협상 과정을 통해 사용하기 가장 좋은 형식을 판별할 것인지의 여부도 설정할 수 있다.

### 리다이렉션

**영구히 리소스가 옮겨진 경우**  
`301` 응답코드와 Location 헤더에 현재 리소스가 존재하고 있는 URL을 보낸다.  
**임시로 리소스가 옮겨진 경우**  
`303`나 `307` 응답코드와 함께 Location 헤더를 보낸다.  
**URL 증강**  
문맥 정보를 포함시키기 위해 재작성된 URL로 리다이 렉트한다.  
`303`나 `307` 응답코드를 사용한다.  
**부하 균형**  
과부하된 서버가 요청을 받으면, 다른 서버로 리다이렉트할 수 있다.  
`303`나 `307` 응답코드를 사용한다.  
**디렉터리 이름 정규화**  
URI 마지막에 `/`이 빠진 경우 이를 포함해 리다이렉트한다.

<br/>

## 단계 6:응답 보내기

<br/>

## 단계 7:로깅
